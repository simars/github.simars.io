webpackJsonp([0x67e839a4967c],{353:function(e,t){e.exports={data:{markdownRemark:{html:"<p><a href=\"https://github.com/ngrx/platform\"><strong>NgRx</strong></a> is an implementation of <a href=\"https://github.com/facebook/flux/tree/master/examples/flux-concepts\">Flux Pattern</a> for angular leveraging R<a href=\"https://angular.io/guide/rx-library\">xJs</a>. Inspired by <a href=\"https://redux.js.org/\"><strong>Redux</strong></a> it uses a centralized state store approach.</p>\n<h3>What’s the genius behind?</h3>\n<p>State is centralized and all mutations are requested by dispatching discrete actions. <code>Reducers</code> are pure functions <code>(action, current-state ) => (new-state)</code> which apply <code>action</code> to the <code>current-state</code> to produce <code>new-state</code> (new instance) with changes applied.</p>\n<p><span class=\"markup--quote markup--p-quote is-other\" name=\"a19f3412a81\" data-creator-ids=\"83ca84c410fe\">Centralizing your application’s state and logic enables powerful capabilities like undo/redo, state persistence, and much more.</span></p>\n<p>We can watch changes, react with side-effects, use “time-travel debugging”, and send complete error reports to a server.</p>\n<p>Redux DevTools make it easy to trace when, where, why, and how application’s state changed.</p>\n<p>Most of the advantages of using this kind of architecture stem from use of centralized state store. In good a <a href=\"https://github.com/ngrx/platform\"><strong>NgRx</strong></a> implementation <strong><em>Container components</em></strong> must depend only on the <strong>Store</strong> for <em>state (selectors and actions)</em>.</p>\n<h3>Router is an essential part of an App’s state</h3>\n<p>If an application uses routes / navigation, the <strong>routing becomes an essential part of your application state</strong>.</p>\n<p>Without incorporating <code>Router</code> in your <code>Store</code>, container components can’t depend on store alone. <code>Components</code> then also need <code>Router</code> / <code>ActivatedRouteSnapshot</code> to figure out <code>path</code> / <code>query</code> <em>params</em> needed to select state of slice from <code>Store</code> and / or dispatch actions to modify the state slice with respect to the current route.</p>\n<h4>What happens router state isn’t part of your central store?</h4>\n<h4>Code Duplication</h4>\n<blockquote>\n<p>Letting <code>components</code> to extract <code>path</code> / <code>query</code> <em>params</em> from <strong><em>navigation / router-state</em></strong> and then use it to <strong><em>select respective state slices and / or dispatch actions</em></strong> we end up with lot of code duplication between sibling components and unnecessary coupling between parent and children components where a child component may need a router param extracted by parent component along side its own.</p>\n</blockquote>\n<h4>Inconsistency</h4>\n<blockquote>\n<p>Users may navigate to a nested route directly, for example by clicking on a shared link, bookmark or even typing in route in browsers navigation bar. We need route params to establish / select the state for target component trees mounted in one ore more the <code>&#x3C;route-outlets/></code> before anything meaningful can render.</p>\n</blockquote>\n<h4>Unmaintainable</h4>\n<blockquote>\n<p>We can’t replay or jump across state snapshots using the redux dev tools as route changes if weren’t reduced by NgRx, can’t be jumped-to or re-played.</p>\n</blockquote>\n<pre><code>/* src/app/pages/ticket-detail/ticket-detail.component.ts */\n\nimport {Component, ElementRef, OnInit, ViewChild} from '@angular/core';  \nimport {ActivatedRoute, Router} from '@angular/router';  \nimport {concat, Observable, of} from 'rxjs';  \nimport {catchError, map, switchMap, tap, combineLatest} from 'rxjs/operators';  \nimport {BackendService, Ticket} from '../../services/backend.service';  \nimport {select, Store} **from** '@ngrx/store';  \nimport {getTickets} **from** '../../reducers/ticket';\n\n@Component({  \n  selector: 'app-ticket-detail',  \n  templateUrl: './ticket-detail.component.html',  \n  styleUrls: ['./ticket-detail.component.css']  \n})  \nexport class TicketDetailComponent implements OnInit {  \n\n  ticket$: Observable&#x3C;Ticket>;  \n  tickets$: Observable&#x3C;Ticket[]>;  \n\n  constructor(  \n              private activatedRoute: ActivatedRoute,  \n              private store: Store,  \n              private router: Router) {  \n\n    ...  \n    this.tickets$ = this.store.pipe(select(getTickets));\n\n    this.ticket$ =  \n      activatedRoute.params.pipe(  \n        map(p => p.id),  \n        combineWithLatest(tickets$),  \n        switchMap(([id, tickets]) => tickets[id],  \n        catchError(error => of({error})),  \n        tap(value => this.form.patchValue({...value}))  \n      );  \n  }  \n\n...  \n\n}\n</code></pre>\n<h3>Solution</h3>\n<p>Following the principle of <a href=\"https://en.wikipedia.org/wiki/Dependency_inversion_principle\"><strong>dependency inversion</strong></a>, if <code>Components</code> extract <em>path / query params</em> from <code>Router</code> state just to use them with their interactions with <code>Store</code>, why not let <code>store/selectors</code> and <code>reducers/side-effects</code> deal with the router and let components depend only the Store?</p>\n<p>We need <a href=\"https://github.com/ngrx/platform/tree/master/modules/router-store\"><strong>ngrx-router-store</strong></a>to reduce route changes into the store and dispatch route change events on the actions stream to allow routes and their mutation to be the part of centralized state in the store.</p>\n<p><strong>Let us wire ngrx-router-store to the App’s NgRx store</strong></p>\n<p><code>npm install @ngrx/router-store — save</code></p>\n<p>If like me, you find angular’s router API hard to collect all path params in the route. Wouldn’t it be nice if we could get all routing state data <code>{data, params, queryParams}</code> ?</p>\n<pre><code>/* ./src/app/reducers/router/merged-route.ts */\nimport {Data, Params} from '@angular/router';\n\nexport interface MergedRoute {\n  url: string;\n  queryParams: Params;\n  params: Params;\n  data: Data;\n}\n</code></pre>\n<p>We can recourse to <a href=\"https://github.com/ngrx/platform/tree/master/modules/router-store\">ngrx-router-store</a> with custom <code>RouterStateSerializer&#x3C;T></code> to give us routing state in a form we like <code>&#x3C;T= MergedRoute></code></p>\n<pre><code>/* src/app/reducers/router/merged-route-serialzer.ts */\nimport {RouterStateSerializer} from '@ngrx/router-store';\nimport {ActivatedRouteSnapshot, Data, Params, RouterStateSnapshot} from '@angular/router';\nimport {MergedRoute} from './merged-route';\n\n\nexport class MergedRouterStateSerializer implements RouterStateSerializer&#x3C;MergedRoute> {\n  serialize(routerState: RouterStateSnapshot): MergedRoute {\n    return {\n      url: routerState.url,\n      params: mergeRouteParams(routerState.root, r => r.params),\n      queryParams: mergeRouteParams(routerState.root, r => r.queryParams),\n      data: mergeRouteData(routerState.root)\n    };\n  }\n}\n\nfunction mergeRouteParams(route: ActivatedRouteSnapshot, getter: (r: ActivatedRouteSnapshot) => Params): Params {\n  if (!route) {\n    return {};\n  }\n  const currentParams = getter(route);\n  const primaryChild = route.children.find(c => c.outlet === 'primary') || route.firstChild;\n  return {...currentParams, ...mergeRouteParams(primaryChild, getter)};\n}\n\nfunction mergeRouteData(route: ActivatedRouteSnapshot): Data {\n  if (!route) {\n    return {};\n  }\n\n  const currentData = route.data;\n  const primaryChild = route.children.find(c => c.outlet === 'primary') || route.firstChild;\n  return {...currentData, ...mergeRouteData(primaryChild)};\n}\n</code></pre>\n<p>To make router state <code>{params, queryParams, data}: MergedRoute</code> a part of our centralized NgRx store <code>state['router']</code>, we will write a <code>module</code> that can simply be included in your App’s <strong>root</strong> <code>module</code></p>\n<pre><code>/* ./src/app/router/ngrx-router.module.ts */\n\nimport {NgModule, Optional, Self} from '@angular/core';\nimport {routerReducer, RouterStateSerializer, StoreRouterConfig, StoreRouterConnectingModule} from '@ngrx/router-store';\nimport {StoreModule} from '@ngrx/store';\nimport {MergedRouterStateSerializer} from './merged-route-serialzer';\nimport {Router} from '@angular/router';\n\nexport const routerStateConfig = {\n  stateKey: 'router', // state-slice name for routing state\n};\n\n@NgModule({\n  imports: [\n    StoreModule.forFeature(routerStateConfig.stateKey, routerReducer),\n    StoreRouterConnectingModule.forRoot(routerStateConfig),\n  ],\n  exports: [\n    StoreModule,\n    StoreRouterConnectingModule\n  ],\n  providers: [\n    {\n      provide: RouterStateSerializer,\n      useClass: MergedRouterStateSerializer,\n    }\n  ]\n})\nexport class NgrxRouterStoreModule {\n\n  constructor(@Self() @Optional() router: Router) {\n    if (router) {\n      console.log('All good, NgrxRouterStoreModule');\n    } else {\n      console.error('NgrxRouterStoreModule must be imported in the same same level as RouterModule');\n\n    }\n  }\n\n}\n</code></pre>\n<p>Let us include the <code>module</code> we defined above into our App’s root module.</p>\n<pre><code>import {ActionReducerMap, MetaReducer, StoreModule} from '@ngrx/store';\nimport {storeFreeze} from 'ngrx-store-freeze';\nimport {NgModule} from '@angular/core';\nimport {StoreDevtoolsModule} from '@ngrx/store-devtools';\nimport {environment} from '../../environments/environment';\nimport {routes} from './routes';\nimport {EffectsModule} from '@ngrx/effects';\nimport {effects} from './effects';\nimport {NgrxRouterStoreModule} from './router/ngrx-router.module.ts';\n\n\nexport const metaReducers: MetaReducer&#x3C;{}>[] =\n  !environment.production ? [storeFreeze] : [];\n\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers as ActionReducerMap&#x3C;{}>, { metaReducers }),\n    EffectsModule.forRoot(effects),\n    !environment.production ? StoreDevtoolsModule.instrument() : [],\n    NgrxRouterStoreModule,\n    BrowserModule,\n    RouterModule.forRoot(routes:)\n  ]\n})\nexport class AppModule {\n}\n</code></pre>\n<p>Router should then be hooked in to your NgRx store. Open redux-dev-tools to see <em>ROUTER_NAVIGATION</em> events with routing state.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*6ZtplKIR53ejm-0E6HhFdw.png\"></p>\n<p>Next we will write selectors for <code>state.router : MergedRoute</code> so we can access to project routing information in any selector and components can be freed from extracting params / queryParams.</p>\n<pre><code>/* src/app/reducers/router/router-state.selectors.ts */\n\nimport {createFeatureSelector, createSelector} from '@ngrx/store';  \nimport {routerStateConfig} from './ngrx-router.module';  \nimport {MergedRouteReducerState} from './index';  \nexport const getRouterReducerState = createFeatureSelector&#x3C;MergedRouteReducerState>(routerStateConfig.stateKey);\nexport const getMergedRoute = createSelector(getRouterReducerState, (routerReducerState) => routerReducerState.state);\n</code></pre>\n<p>For example, if we have component that renders detail of an entity, <code>Ticket</code> based on the :<code>ticketId</code> path param in the route</p>\n<pre><code>/* src/app/reducers/ticket/ticket.selector.ts */\n\nimport {createFeatureSelector, createSelector} from '@ngrx/store';\nimport {TicketReducerState} from './ticket.reducers';\nimport {ticketStateConfig} from './ticket.state';\nimport {getMergedRoute} from '../router/router-state.selectors.ts'\nexport const getTicketReducerState = createFeatureSelector&#x3C;TicketReducerState>(ticketStateConfig.stateKey);\nexport const getTickets = createSelector(getTicketReducerState, (ticketReducerState) => ticketReducerState.state);\nexport const getSelectedTicket = createSelector(getTickets, getMergedRoute,(tickets, mergedRoute) => mergedRoute.params.ticketId);\n</code></pre>\n<p>Finally, here how we can re-write our ticket-detail <code>component</code> to only depend on centralized store</p>\n<pre><code>/* src/app/pages/ticket-detail/ticket-detail.component.ts */\nimport {Component, ElementRef, OnInit, ViewChild} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {concat, Observable, of} from 'rxjs';\nimport {catchError} from 'rxjs/operators';\nimport {BackendService, Ticket} from '../../services/backend.service';\nimport {select, Store} from '@ngrx/store';\nimport {getSelectedTicket} from '../../reducers/ticket';\n@Component({\n  selector: 'app-ticket-detail',\n  templateUrl: './ticket-detail.component.html',\n  styleUrls: ['./ticket-detail.component.css']\n})\nexport class TicketDetailComponent implements OnInit {\n\n  ticket$: Observable&#x3C;Ticket>;\n  \n  constructor(private store: Store) {\n    ...\n    this.ticket$ = this.store.pipe(select(getSelectedTicket));\n  }\n\n...\n\n}\n</code></pre>\n<p>Notice we don’t need to deal with <code>Router</code>, <code>ActivatedRouteSnapshot</code> and battery of <code>RxJs</code> operations to <code>ActivatedRouteSnapshot</code> with <code>store</code> <em>selector</em> <code>getTickets</code>.</p>\n<p>Also, now in your redux-dev-tool, you can work debug easily, replay, jump to any state snapshot, routing actions will be played along.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*g6umBiF9P8pYSb6cj1NGsA.png\"></p>\n<hr>\n<p>This article is also aviable on my <a href=\"https://medium.com/simars/ngrx-router-store-reduce-select-route-params-6baff607dd9?source=friends_link&#x26;sk=f9c40c45fcd293cb9ada8dfcc436f518\"><strong>Medium</strong></a> publication. If you like the artile, or have any comments and suggestions, please <em>clap</em> or leave <em>comments</em> on <a href=\"https://medium.com/simars/ngrx-router-store-reduce-select-route-params-6baff607dd9?source=friends_link&#x26;sk=f9c40c45fcd293cb9ada8dfcc436f518\"><strong>Medium</strong></a>.</p>",frontmatter:{path:"/ngrx-router-store",title:"NgRx Router Store | Reduce & Select Route Params",author:"Simar Paul Singh",date:"2019-01-22"}}},pathContext:{}}}});
//# sourceMappingURL=path---ngrx-router-store-408b3b60e2416bea4264.js.map