{"version":3,"sources":["webpack:///path---create-generic-angular-pipes-apply-and-applypure-0cf3926cb648c5d9256a.js","webpack:///./.cache/json/create-generic-angular-pipes-apply-and-applypure.json"],"names":["webpackJsonp","333","module","exports","data","markdownRemark","html","frontmatter","path","title","author","date","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,8jGAA0yFC,aAAkUC,KAAA,oDAAAC,MAAA,qDAAAC,OAAA,mBAAAC,KAAA,gBAA0KC","file":"path---create-generic-angular-pipes-apply-and-applypure-0cf3926cb648c5d9256a.js","sourcesContent":["webpackJsonp([86583290751729],{\n\n/***/ 333:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<hr>\\n<h3>Fulfill your pipe dream in templates</h3>\\n<ol>\\n<li>Keep one-off (non-reusable) transform impure functions in components, pass them as value-argument to be applied</li>\\n<li>Define your re-usable pure functions separately, and import them in components as needed and pass them as value-argument to be applied</li>\\n</ol>\\n<p>For source click on <a href=\\\"https://github.com/simars/ngx-mix-libraries/blob/master/projects/ngx-mix/src/lib/pipe/apply\\\"><strong>[GitHub]</strong></a> &#x26; To Tryout click on <strong>[</strong><a href=\\\"https://codepen.io/simars/pen/wxRpjN/\\\"><strong>CodePen</strong></a><strong>]</strong></p>\\n<pre name=\\\"991f\\\" id=\\\"991f\\\" class=\\\"graf graf--pre graf-after--p\\\">import { Pipe, PipeTransform } from '@angular/core';  \\n\\n@Pipe({  \\n  name: 'applyPure',  \\n  pure: true // immutable (value) inputs & pure fn (function)  \\n})  \\nexport class ApplyPurePipe implements PipeTransform {  \\n\\n  transform(value: any, fn: Function): any {  \\n    return fn(value);  \\n  }  \\n}  \\n\\n@Pipe({  \\n  name: 'apply',  \\n  pure: false // any (value) inputs & any fn (function)  \\n})  \\nexport class ApplyPipe implements PipeTransform {  \\n\\n  transform(value: any, fn: Function): any {  \\n    return fn(value);  \\n  }  \\n\\n}</pre>\\n<p>Write your functions in components, and pass the function itself as pipe value-arg to be applied</p>\\n<pre name=\\\"3e4b\\\" id=\\\"3e4b\\\" class=\\\"graf graf--pre graf-after--p\\\">[@Component](http://twitter.com/Component \\\"Twitter profile for @Component\\\")({  \\n  selector: 'my-app',  \\n  template: `<p>SUM of {{fib | json}} = {{fib | apply: sum}}</p>`  \\n})  \\nclass AppComponent  {</pre>\\n<pre name=\\\"ab3e\\\" id=\\\"ab3e\\\" class=\\\"graf graf--pre graf-after--pre\\\">fib = [1, 2, 3, 5, 8];</pre>\\n<pre name=\\\"7983\\\" id=\\\"7983\\\" class=\\\"graf graf--pre graf-after--pre\\\">public sum(collection: [number]): number {  \\n    return collection.reduce((first, second) => first + second);  \\n  }  \\n\\n}</pre>\\n<h3>Why do we need two kinds (apply &#x26; applyPure)?</h3>\\n<p><strong>Pure pipes leverage</strong> many advantages which come with <a href=\\\"https://en.wikipedia.org/wiki/Pure_function\\\"><strong>Pure functions</strong></a></p>\\n<ol>\\n<li>First pure pipes <strong>evaluate only when input changes</strong>, second they <strong>cache the outputs for previously evaluated inputs</strong>, and can bind the result from cache <strong>without re-evaluating the pipe expression if the same input was previously evaluated</strong>.</li>\\n<li><strong>Single instance</strong> of a pure pipe is used for all bindings in the app, across components</li>\\n<li><strong>Just need to test transform function</strong>, known input to known output.</li>\\n</ol>\\n<p><strong>Impure pipes</strong> can’t leverage caching, instance re-use and simple tests</p>\\n<h3><strong>When should we declare a Pipe as {pure: false}</strong>?</h3>\\n<ol>\\n<li>Either, the transform function they are evaluating isn’t pure.</li>\\n<li>Or, there is no way to identify or differentiate between different inputs.</li>\\n</ol>\\n<p>(1) is obvious but (2) is something easy to trip over. Let us see it with examples</p>\\n</div>\\n</div>\\n</section>\",\"frontmatter\":{\"path\":\"/create-generic-angular-pipes-apply-and-applypure\",\"title\":\"Create Generic Angular Pipes | apply and applyPure\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-04-22\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---create-generic-angular-pipes-apply-and-applypure-0cf3926cb648c5d9256a.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<hr>\\n<h3>Fulfill your pipe dream in templates</h3>\\n<ol>\\n<li>Keep one-off (non-reusable) transform impure functions in components, pass them as value-argument to be applied</li>\\n<li>Define your re-usable pure functions separately, and import them in components as needed and pass them as value-argument to be applied</li>\\n</ol>\\n<p>For source click on <a href=\\\"https://github.com/simars/ngx-mix-libraries/blob/master/projects/ngx-mix/src/lib/pipe/apply\\\"><strong>[GitHub]</strong></a> &#x26; To Tryout click on <strong>[</strong><a href=\\\"https://codepen.io/simars/pen/wxRpjN/\\\"><strong>CodePen</strong></a><strong>]</strong></p>\\n<pre name=\\\"991f\\\" id=\\\"991f\\\" class=\\\"graf graf--pre graf-after--p\\\">import { Pipe, PipeTransform } from '@angular/core';  \\n\\n@Pipe({  \\n  name: 'applyPure',  \\n  pure: true // immutable (value) inputs & pure fn (function)  \\n})  \\nexport class ApplyPurePipe implements PipeTransform {  \\n\\n  transform(value: any, fn: Function): any {  \\n    return fn(value);  \\n  }  \\n}  \\n\\n@Pipe({  \\n  name: 'apply',  \\n  pure: false // any (value) inputs & any fn (function)  \\n})  \\nexport class ApplyPipe implements PipeTransform {  \\n\\n  transform(value: any, fn: Function): any {  \\n    return fn(value);  \\n  }  \\n\\n}</pre>\\n<p>Write your functions in components, and pass the function itself as pipe value-arg to be applied</p>\\n<pre name=\\\"3e4b\\\" id=\\\"3e4b\\\" class=\\\"graf graf--pre graf-after--p\\\">[@Component](http://twitter.com/Component \\\"Twitter profile for @Component\\\")({  \\n  selector: 'my-app',  \\n  template: `<p>SUM of {{fib | json}} = {{fib | apply: sum}}</p>`  \\n})  \\nclass AppComponent  {</pre>\\n<pre name=\\\"ab3e\\\" id=\\\"ab3e\\\" class=\\\"graf graf--pre graf-after--pre\\\">fib = [1, 2, 3, 5, 8];</pre>\\n<pre name=\\\"7983\\\" id=\\\"7983\\\" class=\\\"graf graf--pre graf-after--pre\\\">public sum(collection: [number]): number {  \\n    return collection.reduce((first, second) => first + second);  \\n  }  \\n\\n}</pre>\\n<h3>Why do we need two kinds (apply &#x26; applyPure)?</h3>\\n<p><strong>Pure pipes leverage</strong> many advantages which come with <a href=\\\"https://en.wikipedia.org/wiki/Pure_function\\\"><strong>Pure functions</strong></a></p>\\n<ol>\\n<li>First pure pipes <strong>evaluate only when input changes</strong>, second they <strong>cache the outputs for previously evaluated inputs</strong>, and can bind the result from cache <strong>without re-evaluating the pipe expression if the same input was previously evaluated</strong>.</li>\\n<li><strong>Single instance</strong> of a pure pipe is used for all bindings in the app, across components</li>\\n<li><strong>Just need to test transform function</strong>, known input to known output.</li>\\n</ol>\\n<p><strong>Impure pipes</strong> can’t leverage caching, instance re-use and simple tests</p>\\n<h3><strong>When should we declare a Pipe as {pure: false}</strong>?</h3>\\n<ol>\\n<li>Either, the transform function they are evaluating isn’t pure.</li>\\n<li>Or, there is no way to identify or differentiate between different inputs.</li>\\n</ol>\\n<p>(1) is obvious but (2) is something easy to trip over. Let us see it with examples</p>\\n</div>\\n</div>\\n</section>\",\"frontmatter\":{\"path\":\"/create-generic-angular-pipes-apply-and-applypure\",\"title\":\"Create Generic Angular Pipes | apply and applyPure\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-04-22\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/create-generic-angular-pipes-apply-and-applypure.json\n// module id = 333\n// module chunks = 86583290751729"],"sourceRoot":""}