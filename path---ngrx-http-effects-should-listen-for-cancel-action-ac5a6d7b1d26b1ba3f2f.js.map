{"version":3,"sources":["webpack:///path---ngrx-http-effects-should-listen-for-cancel-action-ac5a6d7b1d26b1ba3f2f.js","webpack:///./.cache/json/ngrx-http-effects-should-listen-for-cancel-action.json"],"names":["webpackJsonp","352","module","exports","data","markdownRemark","html","frontmatter","path","title","author","date","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,ioHAAunHC,aAAgCC,KAAA,qDAAAC,MAAA,qDAAAC,OAAA,mBAAAC,KAAA,gBAA2KC","file":"path---ngrx-http-effects-should-listen-for-cancel-action-ac5a6d7b1d26b1ba3f2f.js","sourcesContent":["webpackJsonp([29526849648376],{\n\n/***/ 352:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>In a <strong>Ngrx</strong> implementation, a Store Effect loads an entity from from REST APIs when it receives a <code>FETCH_ENTITIES</code> action and then dispatch a <code>FETCHED_ENTITIES</code> action with payload for reducers to merge them in Store.</p>\\n<pre><code>import {Injectable} from '@angular/core';\\nimport {Actions, Effect, ofType} from '@ngrx/effects';\\nimport {catchError, switchMap, map} from 'rxjs/operators';\\nimport {of} from 'rxjs';\\nimport {EntityService} from './';\\n\\n@Injectable()\\nexport class Effects {\\n\\n  constructor(\\n    private actions$: Actions,\\n    private enService: EntityService,\\n    private store: Store&#x3C;{entities: any[]}>\\n  ) {}\\n\\n  @Effect()\\n  getUsers$ = this.actions$.pipe(\\n  ofType('FETCH_ENTITIES', 'CANCEL_FETCH_ENTITIES'),\\n  .switchMap(action => action.type === 'CANCEL_FETCH_ENTITIES' ?\\n    of() :\\n    this.enService.getEntities().pipe(\\n      map(users => ({type: 'FETCHED_ENTITIES', entity})),\\n      catchError(error => of( {type: 'ERROR', error}))\\n      )\\n    )\\n  );\\n}\\n</code></pre>\\n<p>If you notice, the same effect now listens to both <code>ofType(‘FETCH_ENTITIES’, ‘CANCEL_FETCH_ENTITIES’)</code> actions. It can now switch an ongoing <code>this.getEntities()</code> <em>Observable</em> for <code>of()</code> . Upon <code>CANCEL_FETCH_ENTITIES</code> We could also return <code>of({type:'FETCHED_ENTITIES_ACTION, []})</code> depending on what reducing layer expects. However the main point is since we are using <code>switchMap(…)</code> to switch to a different Observable upon <code>CANCEL_FETCH_ENTITIES</code> it will unsubscribe the the previously emitted <code>this.getEntities()</code> <em>http$</em> observable and when the <em>http$</em> observable is unsubscribed will cancel any ongoing requests.</p>\\n<pre><code>import { Injectable } from '@angular/core';\\nimport { HttpClient } from '@angular/common/http';\\n@Injectable()\\nexport class EntityService {\\n  constructor(private http: HttpClient) { }\\n\\n  getEntities() {\\n   return this.http.get&#x3C;any[]>('/api/entities');\\n  }\\n}\\n</code></pre>\\n<p>To learn more about cancel / abort works on an <em>http</em> requests running inside an <code>http&#x3C;div class=\\\"section-inner sectionLayout--insetColumn\\\" on</code>http$.unsubscribe()` checkout <strong><a href=\\\"/rxjs-create_custom_observables_from_event_sources\\\">Custom Observables from Event Sources</a></strong>.</p>\\n<p>Now that our effect processes both <code>ofType(‘FETCH_ENTITIES’, ‘CANCEL_FETCH_ENTITIES’)</code> actions, when should we emit <code>CANCEL_FETCH_ENTITIES</code> ?</p>\\n<p>It depends, sometimes with an explicit user-case where a user clicks on a <code>&#x3C;button (click)=”cancel()”>Cancel&#x3C;/button></code>, to cancel an operation. Trickier one’s are implicit, like when we navigate away and a component which dispatched <code>FETCH_ENTITIES</code> action is getting destroyed.</p>\\n<pre><code>import {select, Store} from '@ngrx/store';\\nimport {Component, OnInit, OnDestroy} from '@angular/core';\\n@Component({\\n  selector: 'some-comp',\\n  template: `\\n  &#x3C;ng-container *ngIf=\\\"en$ | async en; else #loading \\\">\\n   {{en | json}}\\n  &#x3C;/ng-container>\\n  &#x3C;ng-template #loading>\\n     &#x3C;button (click)=\\\"cancel()\\\">Cancel&#x3C;/button>\\n  &#x3C;/ng-template>\\n`\\n})\\nexport class SomeComponent implements OnInit, OnDestroy {\\n   en$: Observable&#x3C;any[]>;\\n   constructor(store: Store) {\\n     this.en$ = this.store.select('entities');\\n   }\\n   cancel() {\\n    this.store.dispatch({type: 'CANCEL_FETCH_ENTITIES'});\\n   }\\n\\n   ngOnInit() {\\n      this.store.dispatch({type: 'FETCH_ENTITIES'});\\n   }\\n   ngOnDestroy() {\\n     this.cancel();\\n   }\\n\\n}\\n</code></pre>\",\"frontmatter\":{\"path\":\"/ngrx-http-effects-should-listen-for-cancel-action\",\"title\":\"Ngrx http$ Effects should listen for CANCEL action\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-10-05\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---ngrx-http-effects-should-listen-for-cancel-action-ac5a6d7b1d26b1ba3f2f.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>In a <strong>Ngrx</strong> implementation, a Store Effect loads an entity from from REST APIs when it receives a <code>FETCH_ENTITIES</code> action and then dispatch a <code>FETCHED_ENTITIES</code> action with payload for reducers to merge them in Store.</p>\\n<pre><code>import {Injectable} from '@angular/core';\\nimport {Actions, Effect, ofType} from '@ngrx/effects';\\nimport {catchError, switchMap, map} from 'rxjs/operators';\\nimport {of} from 'rxjs';\\nimport {EntityService} from './';\\n\\n@Injectable()\\nexport class Effects {\\n\\n  constructor(\\n    private actions$: Actions,\\n    private enService: EntityService,\\n    private store: Store&#x3C;{entities: any[]}>\\n  ) {}\\n\\n  @Effect()\\n  getUsers$ = this.actions$.pipe(\\n  ofType('FETCH_ENTITIES', 'CANCEL_FETCH_ENTITIES'),\\n  .switchMap(action => action.type === 'CANCEL_FETCH_ENTITIES' ?\\n    of() :\\n    this.enService.getEntities().pipe(\\n      map(users => ({type: 'FETCHED_ENTITIES', entity})),\\n      catchError(error => of( {type: 'ERROR', error}))\\n      )\\n    )\\n  );\\n}\\n</code></pre>\\n<p>If you notice, the same effect now listens to both <code>ofType(‘FETCH_ENTITIES’, ‘CANCEL_FETCH_ENTITIES’)</code> actions. It can now switch an ongoing <code>this.getEntities()</code> <em>Observable</em> for <code>of()</code> . Upon <code>CANCEL_FETCH_ENTITIES</code> We could also return <code>of({type:'FETCHED_ENTITIES_ACTION, []})</code> depending on what reducing layer expects. However the main point is since we are using <code>switchMap(…)</code> to switch to a different Observable upon <code>CANCEL_FETCH_ENTITIES</code> it will unsubscribe the the previously emitted <code>this.getEntities()</code> <em>http$</em> observable and when the <em>http$</em> observable is unsubscribed will cancel any ongoing requests.</p>\\n<pre><code>import { Injectable } from '@angular/core';\\nimport { HttpClient } from '@angular/common/http';\\n@Injectable()\\nexport class EntityService {\\n  constructor(private http: HttpClient) { }\\n\\n  getEntities() {\\n   return this.http.get&#x3C;any[]>('/api/entities');\\n  }\\n}\\n</code></pre>\\n<p>To learn more about cancel / abort works on an <em>http</em> requests running inside an <code>http&#x3C;div class=\\\"section-inner sectionLayout--insetColumn\\\" on</code>http$.unsubscribe()` checkout <strong><a href=\\\"/rxjs-create_custom_observables_from_event_sources\\\">Custom Observables from Event Sources</a></strong>.</p>\\n<p>Now that our effect processes both <code>ofType(‘FETCH_ENTITIES’, ‘CANCEL_FETCH_ENTITIES’)</code> actions, when should we emit <code>CANCEL_FETCH_ENTITIES</code> ?</p>\\n<p>It depends, sometimes with an explicit user-case where a user clicks on a <code>&#x3C;button (click)=”cancel()”>Cancel&#x3C;/button></code>, to cancel an operation. Trickier one’s are implicit, like when we navigate away and a component which dispatched <code>FETCH_ENTITIES</code> action is getting destroyed.</p>\\n<pre><code>import {select, Store} from '@ngrx/store';\\nimport {Component, OnInit, OnDestroy} from '@angular/core';\\n@Component({\\n  selector: 'some-comp',\\n  template: `\\n  &#x3C;ng-container *ngIf=\\\"en$ | async en; else #loading \\\">\\n   {{en | json}}\\n  &#x3C;/ng-container>\\n  &#x3C;ng-template #loading>\\n     &#x3C;button (click)=\\\"cancel()\\\">Cancel&#x3C;/button>\\n  &#x3C;/ng-template>\\n`\\n})\\nexport class SomeComponent implements OnInit, OnDestroy {\\n   en$: Observable&#x3C;any[]>;\\n   constructor(store: Store) {\\n     this.en$ = this.store.select('entities');\\n   }\\n   cancel() {\\n    this.store.dispatch({type: 'CANCEL_FETCH_ENTITIES'});\\n   }\\n\\n   ngOnInit() {\\n      this.store.dispatch({type: 'FETCH_ENTITIES'});\\n   }\\n   ngOnDestroy() {\\n     this.cancel();\\n   }\\n\\n}\\n</code></pre>\",\"frontmatter\":{\"path\":\"/ngrx-http-effects-should-listen-for-cancel-action\",\"title\":\"Ngrx http$ Effects should listen for CANCEL action\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-10-05\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/ngrx-http-effects-should-listen-for-cancel-action.json\n// module id = 352\n// module chunks = 29526849648376"],"sourceRoot":""}