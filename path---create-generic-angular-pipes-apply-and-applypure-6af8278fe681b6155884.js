webpackJsonp([86583290751729],{333:function(n,e){n.exports={data:{markdownRemark:{html:"<hr>\n<h3>Fulfill your pipe dream in templates</h3>\n<ol>\n<li>Keep one-off (non-reusable) transform impure functions in components, pass them as value-argument to be applied</li>\n<li>Define your re-usable pure functions separately, and import them in components as needed and pass them as value-argument to be applied</li>\n</ol>\n<p>For source click on <a href=\"https://github.com/simars/ngx-mix-libraries/blob/master/projects/ngx-mix/src/lib/pipe/apply\"><strong>[GitHub]</strong></a> &#x26; To Tryout click on <strong>[</strong><a href=\"https://codepen.io/simars/pen/wxRpjN/\"><strong>CodePen</strong></a><strong>]</strong></p>\n<pre>\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({  \n  name: 'applyPure',  \n  pure: true // immutable (value) inputs & pure fn (function)  \n})  \nexport class ApplyPurePipe implements PipeTransform {  \n\n  transform(value: any, fn: Function): any {  \n    return fn(value);  \n  }  \n}  \n\n@Pipe({  \n  name: 'apply',  \n  pure: false // any (value) inputs & any fn (function)  \n})  \nexport class ApplyPipe implements PipeTransform {  \n\n  transform(value: any, fn: Function): any {  \n    return fn(value);  \n  }  \n\n}\n</pre>\n<p>Write your functions in components, and pass the function itself as pipe value-arg to be applied</p>\n<pre>\n@Component()({\n  selector: 'my-app',  \n  template: `&lt;p&gt;SUM of {{fib | json}} = {{fib | apply: sum}}&lt;/p&gt;`\n})  \nclass AppComponent  {\n\nfib = [1, 2, 3, 5, 8];\n\npublic sum(collection: [number]): number {\n    return collection.reduce((first, second) => first + second);\n  }  \n\n}\n</pre>\n<h3>Why do we need two kinds (apply &#x26; applyPure)?</h3>\n<p><strong>Pure pipes leverage</strong> many advantages which come with <a href=\"https://en.wikipedia.org/wiki/Pure_function\"><strong>Pure functions</strong></a></p>\n<ol>\n<li>First pure pipes <strong>evaluate only when input changes</strong>, second they <strong>cache the outputs for previously evaluated inputs</strong>, and can bind the result from cache <strong>without re-evaluating the pipe expression if the same input was previously evaluated</strong>.</li>\n<li><strong>Single instance</strong> of a pure pipe is used for all bindings in the app, across components</li>\n<li><strong>Just need to test transform function</strong>, known input to known output.</li>\n</ol>\n<p><strong>Impure pipes</strong> can’t leverage caching, instance re-use and simple tests</p>\n<h3><strong>When should we declare a Pipe as {pure: false}</strong>?</h3>\n<ol>\n<li>Either, the transform function they are evaluating isn’t pure.</li>\n<li>Or, there is no way to identify or differentiate between different inputs.</li>\n</ol>\n<p>(1) is obvious but (2) is something easy to trip over. Let us see it with examples</p>\n<h2>Try it out on <strong>[</strong><a href=\"https://codepen.io/simars/pen/wxRpjN/\"><strong>CodePen</strong></a><strong>]</strong></h2>\n<iframe height='844' scrolling='no' title='angular-apply-pipes' src='//codepen.io/simars/embed/wxRpjN/?height=265&theme-id=0&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/simars/pen/wxRpjN/'>angular-apply-pipes</a> by Simar Paul Singh (<a href='https://codepen.io/simars'>@simars</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>",frontmatter:{path:"/create-generic-angular-pipes-apply-and-applypure",title:"Create Generic Angular Pipes | apply and applyPure",author:"Simar Paul Singh",date:"2018-04-22"}}},pathContext:{}}}});
//# sourceMappingURL=path---create-generic-angular-pipes-apply-and-applypure-6af8278fe681b6155884.js.map