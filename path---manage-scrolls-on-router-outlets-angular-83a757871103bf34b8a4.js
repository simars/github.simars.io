webpackJsonp([0xcb4119a2f0b3],{342:function(e,t){e.exports={data:{markdownRemark:{html:'<hr>\n<p><strong>Angular</strong> Single Page Applications (<strong>SPA</strong>s) handle routes with <code>router-outlets</code>, keeping the browser window on the same page (<code>index.html</code>), enriching experience after initial page load with just post-back / ajax calls</p>\n<p>However, by <span class="markup--quote markup--p-quote is-other" name="24f1c4d769fe" data-creator-ids="a31b1c2b9e8f">preventing the Browser Window from reacting on route change (fetch a new page), now <code>router-outlet</code> (s) must assume the responsibility of what a browser Window usually does on fetching a new page</span> “<em>Scrolls are reset on the Window, and the complete DOM is new. Neither the window, nor elements retain any scroll state from the previous page.</em>”</p>\n<p>How angular Router works is very well explained <a href="https://vsavkin.com/angular-router-understanding-router-state-7b5b95a12eab">here</a>. Once a route is activated, by default routing strategy, all navigation changes matching the route <code>[URL]-> {router-outlet, component}</code> are pushed through the same instance of the <code>component</code> activated inside the target /current <code>router-outlet</code> until we navigate out to a parent route, or where a different route-tree.</p>\n<p>This means we could store the state of scrolls before a <code>router-outlet</code> activates, and restore the previous state when its destroyed.</p>\n<p>Let’s solve this with a directive that targets all <code>router-outlet</code></p>\n<pre>\n import {Attribute, Directive, ElementRef, Inject, InjectionToken, OnDestroy, OnInit, Optional} from \'[@angular/core](http://twitter.com/angular/core "Twitter profile for @angular/core")\';\n import {Event, NavigationEnd, Router} from \'[@angular/router](http://twitter.com/angular/router "Twitter profile for @angular/router")\';\n import {Subscription} from \'rxjs/Subscription\';\n import {distinctUntilChanged, filter} from \'rxjs/operators\';\n @Directive()({\n   selector: \'router-outlet\'\n })\n export class RouterOutletDirective implements OnInit, OnDestroy {\n\n  private routerEventsSubscription: Subscription;\n  private currentXY: WindowXY;\n\n  constructor(  \n    private elementRef: ElementRef,  \n    private router: Router  \n  ) {  \n    this.elementRef = elementRef;  \n    this.router = router;  \n    this.routerEventsSubscription = null;  \n  }\n\n  public ngOnDestroy(): void {\n    if (this.routerEventsSubscription) {  \n      this.routerEventsSubscription.unsubscribe();  \n    }  \n    this.windowCoordinates = this.currentXY;  \n  }\n\n  public ngOnInit(): void {\n    this.currentXY = this.windowCoordinates;  \n    this.windowScroll = [0, 0] as WindowXY; // reset window scroll\n    this.routerEventsSubscription = this.router.events.pipe(\n      filter((event) => event instanceof NavigationEnd),  \n      distinctUntilChanged((prev: NavigationEnd, next: NavigationEnd) => next && next.url === prev.url)  \n    )  \n      .subscribe(  \n        (event: Event): void => {  \n          const node = this.elementRef.nativeElement.parentNode;  \n          node.scrollTop = 0;  \n        }  \n      );  \n  }\n\n  private get windowCoordinates(): WindowXY {\n    return [window.scrollX, window.scrollY] as WindowXY;  \n  }\n\n  private set windowCoordinates(xy: WindowXY): WindowXY {\n    window.scrollTo(xy[0] || 0, xy[1] || 0);  \n  }\n }\n</pre>\n<p>Notice, every time the route changes, the directive will grab the parent element and set <code>scrollTop</code> to <code>0</code> so if the component filling in the outlet has a content overflow with scroll, the scroll reset to top on every route change. (Assuming scroll is from parent-element to <code>router-outlet</code> marked <code>overflow: scroll</code> ).</p>\n<p>Also, every time a <code>router-outlet</code> activates, the directive instance will note-down the current coordinates of the browser window, and restore the same coordinates when the <code>router-outlet</code> deactivates. This is useful in case we have multiple outlets, with int he same app, are in multi-app setup</p>\n<p>Since the directive subscribes to navigation events, any change in the <code>window.location</code> whether it be through back button, router-navigation etc, the directive resets the scroll in-line with how browser window does when we navigate to a new page.</p>\n<p>You could further enhance this directive, to remember last known scroll-positions (<code>window</code> and <code>router-outlet</code> directive‘s parent) for every URL that directive receives from navigation change subscription. To to store <code>url->coordinates</code> we could leverage an <code>angular-service</code> . If you want to remember the last scroll positions to each URL across browser refreshes / page reloads, use <code>history-api</code> and/or <code>local-storage</code></p>\n<p>You may have to deal with secondary outlets differently. Main idea here is the scroll on <code>window</code> and elements on top of <code>router-outlet</code> s need to managed.</p>',frontmatter:{path:"/manage-scrolls-on-router-outlets-angular",title:"Manage Scrolls on router-outlets | Angular",author:"Simar Singh",date:"2018-05-30"}}},pathContext:{}}}});
//# sourceMappingURL=path---manage-scrolls-on-router-outlets-angular-83a757871103bf34b8a4.js.map