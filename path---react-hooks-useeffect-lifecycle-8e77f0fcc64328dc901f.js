webpackJsonp([0xa6e26dae13ad],{355:function(e,n){e.exports={data:{markdownRemark:{html:'<p><code>useEffect()</code> can combine <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> but is tricky.</p>\n<p>You can decipher most of what I have to discuss here from official docs for <a href="https://reactjs.org/docs/hooks-effect.html">hooks</a>. It’s easier to see hooks at work, than to reason from text.</p>\n<h3><strong>Pre-render lifecycle</strong></h3>\n<p><strong>Pre-render lifecycle</strong> events equivalent to <code>componentWillReceiveProps</code> or <code>getDerivedStateFromProps</code> and <code>componentWillMount</code> can just be the things we do first in the functional component before returning JSX (react-node) as the function itself is equivalent to <code>render(…)</code> method of class based component.</p>\n<p><strong><em>We don’t need hooks handling Pre-render lifecycle events.</em></strong></p>\n<h3><strong>Post-render lifecycle</strong></h3>\n<p><strong>Post-render lifecycle</strong> events, those equivalent to <code>componentDidMount</code>, <code>componentDidUpdate</code> and <code>componentWillUnmount</code> in class based component.</p>\n<p><strong><em>We need to</em> **<em><code>useEffect(…)</code></em></strong> <em>to handle these Post-render lifecycle events</em>** as we can’t write the logic tied to these lifecycle events inside the main component function as these should run after the component function returns JSX (react-node) to <code>react-dom</code> renderer.</p>\n<p>This means, we have lot we can do with hooks. How?</p>\n<p>We know <code>useEffect(fn, […watchStates])</code>, takes in 2 arguments.</p>\n<ol>\n<li><code>fn</code>: (required) <code>useEffect</code> invokes this function to run as side-effect after every render cycle based on values being tracked for changes given by the (2) argument. The function <code>fn</code>, could return another function that should be run as a cleanup before the effect function runs again or component un-mounts</li>\n<li><code>[…watchValues ]</code>: (optional) <code>useEffect</code> tracks values in this array has changed from the last render cycle then only effect <code>fn</code> is invoked. If this argument is not given, the effect will run with every render cycle.</li>\n</ol>\n<p>If we don’t pass the (2) argument all-together, the effect logic in <code>fn</code> will be invoked after every render cycle.</p>\n<p>If we pass (2) array with values the component needs to watch for changes, and invoke <code>fn</code> on change, pretty self explanatory.</p>\n<p>The trickiest part is in using an empty array <code>[]</code> as the (2) argument, we can restrict side-effect logic in <code>fn</code> to execute only during the mounting phase as there are no changes effect hook would be watching for after subsequent render-cycles to trigger <code>fn</code> again.</p>\n<pre><code>import React, { useState, useEffect } from "react";\nexport default props => {\n  console.log("componentWillMount");\n  console.log("componentWillReceiveProps", props);\n  const [x, setX] = useState(0);\n  const [y, setY] = useState(0);\n  const [moveCount, setMoveCount] = useState(0);\n  const [cross, setCross] = useState(0);\n  const mouseMoveHandler = event => {\n    setX(event.clientX);\n    setY(event.clientY);\n  };\n  useEffect(() => {\n    console.log("componentDidMount");\n    document.addEventListener("mousemove", mouseMoveHandler);\n    return () => {\n      console.log("componentWillUnmount");\n      document.removeEventListener("mousemove", mouseMoveHandler);\n    };\n  }, []); // empty-array means don\'t watch for any updates\n  useEffect(\n    () => {\n      // if (componentDidUpdate &#x26; (x or y changed))\n      setMoveCount(moveCount + 1);\n    },\n    [x, y]\n  );\n  useEffect(() => {\n    // if componentDidUpdate or componentDidMount\n    if (x === y) {\n      setCross(x);\n    }\n  });\n  return (\n    &#x3C;div>\n      &#x3C;p style={{ color: props.color }}>\n        Your mouse is at {x}, {y} position.\n      &#x3C;/p>\n      &#x3C;p>Your mouse has moved {moveCount} times&#x3C;/p>\n      &#x3C;p>\n        X and Y positions were last equal at {cross}, {cross}\n      &#x3C;/p>\n    &#x3C;/div>\n  );\n};\n</code></pre>\n<iframe src="https://codesandbox.io/embed/q38wpvvonq?fontsize=14&module=%2Fsrc%2FExample.jsx" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>\n<p>The code snippet is simple and self explanatory. You can try it out on code-pen.</p>\n<p>One important thing to note is that if you are making a state change inside a effect, ensure you exclude the state that’s changing inside from the watch array.</p>\n<p>For example in the second effect (one that counts the mouse movements) we only trigger it on updates on x and y, by passing <code>[x , y]</code> as the second argument because</p>\n<ol>\n<li>Its logically correct to watch for changes to x and y to register a mouse movement</li>\n<li>If we don’t exclude moveCount from being watched, this useEffect will go into an infinite cycle, as we will be updating the same value we are also watching for changes</li>\n</ol>\n<hr>\n<p>This article is also aviable on my <a href="https://medium.com/simars/react-hooks-manage-life-cycle-events-tricks-and-tips-7ed13f52ba12?source=friends_link&#x26;sk=1e75c8c90b14ba96ec94b114dfeeb54e"><strong>Medium</strong></a> publication. If you like the artile, or have any comments and suggestions, please <strong><em>clap</em></strong> or leave <strong><em>comments</em></strong> on <a href="https://medium.com/simars/react-hooks-manage-life-cycle-events-tricks-and-tips-7ed13f52ba12?source=friends_link&#x26;sk=1e75c8c90b14ba96ec94b114dfeeb54e"><strong>Medium</strong></a>.</p>',frontmatter:{path:"/react-hooks-useeffect-lifecycle",title:"React Hooks | useEffect for Life-Cycle Events (Tricks & Tips)",author:"Simar Paul Singh",date:"2019-03-16"}}},pathContext:{}}}});
//# sourceMappingURL=path---react-hooks-useeffect-lifecycle-8e77f0fcc64328dc901f.js.map