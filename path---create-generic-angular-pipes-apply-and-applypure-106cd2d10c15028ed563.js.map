{"version":3,"sources":["webpack:///path---create-generic-angular-pipes-apply-and-applypure-106cd2d10c15028ed563.js","webpack:///./.cache/json/create-generic-angular-pipes-apply-and-applypure.json"],"names":["webpackJsonp","333","module","exports","data","markdownRemark","html","frontmatter","path","title","author","date","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,wkLAAikLC,aAA6BC,KAAA,oDAAAC,MAAA,uDAAAC,OAAA,mBAAAC,KAAA,gBAA4KC","file":"path---create-generic-angular-pipes-apply-and-applypure-106cd2d10c15028ed563.js","sourcesContent":["webpackJsonp([86583290751729],{\n\n/***/ 333:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<hr>\\n<h2>Testing Angular Directives with a fake TestComponent</h2>\\n<p>Directives are an important construct in angular to make <strong>DOM</strong> <em>manipulation</em> and / or <em>event handling</em> abstract.</p>\\n<p><strong>We must <em>Unit Test</em> directives by mocking all dependencies of directive.</strong></p>\\n<ol>\\n<li>Very Simple to write, no need for TestBed, just work with jasmine spies and mocks</li>\\n<li>Run them as often, fast and effective</li>\\n</ol>\\n<p><strong>Since directive work on components (compiled DOM) we must also test them with an actual component</strong></p>\\n<ol>\\n<li>Need TestComponent, and TestBed, to create a TestModule which compiles your fake TestComponent with directive to be tested</li>\\n<li>Dependencies to the fake TestComponent are mocked, instead of mocking the containerRef to directive</li>\\n<li>Besides little complexity setting up the TestBed, fast and effective</li>\\n</ol>\\n<p>Unit Tests are easy to write and understand. We are going to discuss here testing of directives with an actual TestComponent</p>\\n<h2>Lets write some tests</h2>\\n<ol>\\n<li>Keep one-off (non-reusable) transform impure functions in components, pass them as value-argument to be applied</li>\\n<li>Define your re-usable pure functions separately, and import them in components as needed and pass them as value-argument to be applied</li>\\n</ol>\\n<p>For source click on <a href=\\\"https://github.com/simars/ngx-mix-libraries/blob/master/projects/ngx-mix/src/lib/pipe/apply\\\"><strong>[GitHub]</strong></a> &#x26; To Tryout click on <strong>[</strong><a href=\\\"https://codepen.io/simars/pen/wxRpjN/\\\"><strong>CodePen</strong></a><strong>]</strong></p>\\n<p>Consider a simple directive, which can be applied as an attribute <code>disabled</code> go any anchor tag</p>\\n<pre>\\nimport {Directive, Input} from '@angular/core';\\nimport {NgControl} from '@angular/forms';\\n\\n@Directive({\\n  selector: '[disableControl]'\\n})\\nexport class DisableControlDirective {\\n\\n  @Input() set disableControl(condition: boolean) {\\n    this.ngControl.control[condition ? 'disable' : 'enable']();\\n  }\\n\\n  constructor(private ngControl: NgControl) {}\\n}\\n\\n</pre>\\n<p>Write your functions in components, and pass the function itself as pipe value-arg to be applied</p>\\n<pre>\\n\\nimport {DisableLinkDirective} from './disable-link.directive';\\nimport {Component, DebugElement} from '@angular/core';\\nimport {ComponentFixture, TestBed} from '@angular/core/testing';\\nimport {By} from '@angular/platform-browser';\\n\\n@Component(\\n  {\\n    selector: 'ngx-mix-test-disable-link-directive',\\n    template: `\\n      &lt;div&gt;\\n          &lt;a id=&quot;disabled-link&quot; disabled (click)=&quot;onClick()&quot;&gt;Disabled Link&lt;/a&gt;\\n          &lt;a id=&quot;normal-link&quot; (click)=&quot;onClick()&quot;&gt;Normal Link&lt;/a&gt;\\n          &lt;a id=&quot;conditional-link&quot; [attr.disabled]=&quot;toggle&quot; (click)=&quot;onClick()&quot;&gt;Normal Link&lt;/a&gt;\\n      &lt;/div&gt;\\n    `\\n  }\\n)\\nclass TestDisableLinkComponent {\\n\\n  toggle = false;\\n\\n  onClick() {\\n    this.toggle = !this.toggle;\\n  }\\n\\n}\\n\\n\\ndescribe('DisableLinkDirective', () => {\\n\\n  let component: TestDisableLinkComponent;\\n  let fixture: ComponentFixture<TestDisableLinkComponent>;\\n\\n  beforeEach(async () => {\\n\\n    await TestBed.configureTestingModule({\\n      declarations: [TestDisableLinkComponent, DisableLinkDirective]\\n    }).compileComponents();\\n  });\\n\\n  beforeEach(async () => {\\n    fixture = TestBed.createComponent(TestDisableLinkComponent);\\n    component = fixture.componentInstance;\\n    fixture.detectChanges();\\n  });\\n\\n  it('should create an instance', () => {\\n    const directive = new DisableLinkDirective();\\n    expect(directive).toBeTruthy();\\n  });\\n\\n\\n  it('should not toggle between enabled / disabled when the link with disabled attribute is clicked', async () => {\\n    const testDe: DebugElement = fixture.debugElement;\\n    const linkDe = testDe.query(By.css('#disabled-link'));\\n    const link: HTMLElement = linkDe.nativeElement;\\n    await expect(link.getAttribute('disabled')).not.toBe(null);\\n    const toggleValueBeforeClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeClick).toBe(component.toggle);\\n  });\\n\\n  it('should toggle between enabled / disabled when the link does not have disabled attribute', async () => {\\n    const testDe: DebugElement = fixture.debugElement;\\n    const linkDe = testDe.query(By.css('#normal-link'));\\n    const link: HTMLElement = linkDe.nativeElement;\\n    await expect(link.getAttribute('disabled')).toBe(null);\\n    const toggleValueBeforeClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeClick).not.toBe(component.toggle);\\n  });\\n\\n  it('should toggle between enabled / disabled only once as the link disables with first toggle', async () => {\\n    const testDe: DebugElement = fixture.debugElement;\\n    const linkDe = testDe.query(By.css('#conditional-link'));\\n    const toggleValueBeforeClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeClick).not.toBe(component.toggle);\\n    const toggleValueBeforeSecondClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeSecondClick).not.toBe(component.toggle);\\n  });\\n\\n});\\n\\n\\n</pre>\",\"frontmatter\":{\"path\":\"/create-generic-angular-pipes-apply-and-applypure\",\"title\":\"Testing Angular Directives with a fake TestComponent\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-04-22\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---create-generic-angular-pipes-apply-and-applypure-106cd2d10c15028ed563.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<hr>\\n<h2>Testing Angular Directives with a fake TestComponent</h2>\\n<p>Directives are an important construct in angular to make <strong>DOM</strong> <em>manipulation</em> and / or <em>event handling</em> abstract.</p>\\n<p><strong>We must <em>Unit Test</em> directives by mocking all dependencies of directive.</strong></p>\\n<ol>\\n<li>Very Simple to write, no need for TestBed, just work with jasmine spies and mocks</li>\\n<li>Run them as often, fast and effective</li>\\n</ol>\\n<p><strong>Since directive work on components (compiled DOM) we must also test them with an actual component</strong></p>\\n<ol>\\n<li>Need TestComponent, and TestBed, to create a TestModule which compiles your fake TestComponent with directive to be tested</li>\\n<li>Dependencies to the fake TestComponent are mocked, instead of mocking the containerRef to directive</li>\\n<li>Besides little complexity setting up the TestBed, fast and effective</li>\\n</ol>\\n<p>Unit Tests are easy to write and understand. We are going to discuss here testing of directives with an actual TestComponent</p>\\n<h2>Lets write some tests</h2>\\n<ol>\\n<li>Keep one-off (non-reusable) transform impure functions in components, pass them as value-argument to be applied</li>\\n<li>Define your re-usable pure functions separately, and import them in components as needed and pass them as value-argument to be applied</li>\\n</ol>\\n<p>For source click on <a href=\\\"https://github.com/simars/ngx-mix-libraries/blob/master/projects/ngx-mix/src/lib/pipe/apply\\\"><strong>[GitHub]</strong></a> &#x26; To Tryout click on <strong>[</strong><a href=\\\"https://codepen.io/simars/pen/wxRpjN/\\\"><strong>CodePen</strong></a><strong>]</strong></p>\\n<p>Consider a simple directive, which can be applied as an attribute <code>disabled</code> go any anchor tag</p>\\n<pre>\\nimport {Directive, Input} from '@angular/core';\\nimport {NgControl} from '@angular/forms';\\n\\n@Directive({\\n  selector: '[disableControl]'\\n})\\nexport class DisableControlDirective {\\n\\n  @Input() set disableControl(condition: boolean) {\\n    this.ngControl.control[condition ? 'disable' : 'enable']();\\n  }\\n\\n  constructor(private ngControl: NgControl) {}\\n}\\n\\n</pre>\\n<p>Write your functions in components, and pass the function itself as pipe value-arg to be applied</p>\\n<pre>\\n\\nimport {DisableLinkDirective} from './disable-link.directive';\\nimport {Component, DebugElement} from '@angular/core';\\nimport {ComponentFixture, TestBed} from '@angular/core/testing';\\nimport {By} from '@angular/platform-browser';\\n\\n@Component(\\n  {\\n    selector: 'ngx-mix-test-disable-link-directive',\\n    template: `\\n      &lt;div&gt;\\n          &lt;a id=&quot;disabled-link&quot; disabled (click)=&quot;onClick()&quot;&gt;Disabled Link&lt;/a&gt;\\n          &lt;a id=&quot;normal-link&quot; (click)=&quot;onClick()&quot;&gt;Normal Link&lt;/a&gt;\\n          &lt;a id=&quot;conditional-link&quot; [attr.disabled]=&quot;toggle&quot; (click)=&quot;onClick()&quot;&gt;Normal Link&lt;/a&gt;\\n      &lt;/div&gt;\\n    `\\n  }\\n)\\nclass TestDisableLinkComponent {\\n\\n  toggle = false;\\n\\n  onClick() {\\n    this.toggle = !this.toggle;\\n  }\\n\\n}\\n\\n\\ndescribe('DisableLinkDirective', () => {\\n\\n  let component: TestDisableLinkComponent;\\n  let fixture: ComponentFixture<TestDisableLinkComponent>;\\n\\n  beforeEach(async () => {\\n\\n    await TestBed.configureTestingModule({\\n      declarations: [TestDisableLinkComponent, DisableLinkDirective]\\n    }).compileComponents();\\n  });\\n\\n  beforeEach(async () => {\\n    fixture = TestBed.createComponent(TestDisableLinkComponent);\\n    component = fixture.componentInstance;\\n    fixture.detectChanges();\\n  });\\n\\n  it('should create an instance', () => {\\n    const directive = new DisableLinkDirective();\\n    expect(directive).toBeTruthy();\\n  });\\n\\n\\n  it('should not toggle between enabled / disabled when the link with disabled attribute is clicked', async () => {\\n    const testDe: DebugElement = fixture.debugElement;\\n    const linkDe = testDe.query(By.css('#disabled-link'));\\n    const link: HTMLElement = linkDe.nativeElement;\\n    await expect(link.getAttribute('disabled')).not.toBe(null);\\n    const toggleValueBeforeClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeClick).toBe(component.toggle);\\n  });\\n\\n  it('should toggle between enabled / disabled when the link does not have disabled attribute', async () => {\\n    const testDe: DebugElement = fixture.debugElement;\\n    const linkDe = testDe.query(By.css('#normal-link'));\\n    const link: HTMLElement = linkDe.nativeElement;\\n    await expect(link.getAttribute('disabled')).toBe(null);\\n    const toggleValueBeforeClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeClick).not.toBe(component.toggle);\\n  });\\n\\n  it('should toggle between enabled / disabled only once as the link disables with first toggle', async () => {\\n    const testDe: DebugElement = fixture.debugElement;\\n    const linkDe = testDe.query(By.css('#conditional-link'));\\n    const toggleValueBeforeClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeClick).not.toBe(component.toggle);\\n    const toggleValueBeforeSecondClick = component.toggle;\\n    linkDe.triggerEventHandler('click', null);\\n    fixture.detectChanges();\\n    await fixture.whenStable();\\n    await expect(toggleValueBeforeSecondClick).not.toBe(component.toggle);\\n  });\\n\\n});\\n\\n\\n</pre>\",\"frontmatter\":{\"path\":\"/create-generic-angular-pipes-apply-and-applypure\",\"title\":\"Testing Angular Directives with a fake TestComponent\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-04-22\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/create-generic-angular-pipes-apply-and-applypure.json\n// module id = 333\n// module chunks = 86583290751729"],"sourceRoot":""}