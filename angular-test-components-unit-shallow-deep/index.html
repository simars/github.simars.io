<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/component---src-layouts-index-js-666f50598e70c7b6e5d1.js" as="script"/><link rel="preload" href="/component---src-templates-blog-post-js-0668ad1c8e9fa38db975.js" as="script"/><link rel="preload" href="/path---angular-test-components-unit-shallow-deep-177aca4874a2ff4db95f.js" as="script"/><link rel="preload" href="/app-28a5d26ae4a6a7b6ddd4.js" as="script"/><link rel="preload" href="/commons-403258ad126d5c26671b.js" as="script"/><title data-react-helmet="true">Simars.io</title><meta data-react-helmet="true" name="description" content="Simar Paul Singh | Personal Portal and Blog "/><meta data-react-helmet="true" name="keywords" content="simars, blog, programming, coding, learning, tutorial, angular, ES, ECMAScript, JS, JavaScript, TS ,TypeScript gatsby, react, Java, Kotlin, Spring"/><style id="gatsby-inlined-css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}.row{-ms-flex-direction:row;flex-direction:row}.column,.row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:distribute;justify-content:space-around}.column{-ms-flex-direction:column;flex-direction:column}a{border:none;background:transparent url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNjEycHgiIGhlaWdodD0iNjEycHgiIHZpZXdCb3g9IjAgMCA2MTIgNjEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA2MTIgNjEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPGcgaWQ9IkxpbmsiPgoJCTxnPgoJCQk8cGF0aCBkPSJNMzUwLjE3OSwyMTUuNDYyYy02LjY5My00LjMwMy0xNC40OTctNS40Ny0yMS43MDctMy44NjNjLTcuMTM0LDEuNTg3LTEzLjY3NCw1Ljg5LTE3LjkzOSwxMi41MjcKCQkJCWMtNC4yODQsNi42NzQtNS40NSwxNC40MzktMy44NjIsMjEuNjExYzEuNTY3LDcuMTcyLDUuODcxLDEzLjc1LDEyLjUyNiwxOC4wMTZjMjcuNjc0LDE3LjcyOSw0NC4xNzksNDcuODMyLDQ0LjE3OSw4MC40OTcKCQkJCWMwLDI1LjU1MS05Ljk0NSw0OS41NTMtMjcuOTk5LDY3LjYwNmwtMTE0Ljc1LDExNC43NWMtMTguMDczLDE4LjA3My00Mi4wOTQsMjguMDE5LTY3LjYyNiwyOC4wMTkKCQkJCWMtNTIuNzI4LDAtOTUuNjI1LTQyLjg5Ny05NS42MjUtOTUuNjI1YzAtMjUuNTUxLDkuOTQ1LTQ5LjU1MywyNy45OTktNjcuNjA2bDU0LjQzLTU0LjQ0OWM1LjczNy01LjczNyw4LjUzLTEzLjI5Miw4LjQxNS0yMC44MDgKCQkJCWMtMC4xMzQtNy4xNzItMi45MjYtMTQuMjg3LTguNDE1LTE5Ljc1N2MtNS42MDQtNS42MDQtMTIuOTQ4LTguNDE1LTIwLjI3Mi04LjQxNWMtNy4zNDQsMC0xNC42ODgsMi43OTItMjAuMjcyLDguNDE1CgkJCQlsLTU0LjQzLDU0LjQ0OUMxNS45MTIsMzc5LjcwOCwwLDQxOC4xMywwLDQ1OWMwLDg0LjM2LDY4LjY0LDE1MywxNTMsMTUzYzQwLjg3LDAsNzkuMjkyLTE1LjkxMiwxMDguMTktNDQuODI5bDExNC43NS0xMTQuNzUKCQkJCWMyOC44OTctMjguODU5LDQ0LjgxLTY3LjMwMSw0NC44MS0xMDguMTcxQzQyMC43NSwyOTEuOTQzLDM5NC4zNzcsMjQzLjgwNiwzNTAuMTc5LDIxNS40NjJ6IE00NTksMAoJCQkJYy00MC44NywwLTc5LjI5MiwxNS45MTItMTA4LjE5LDQ0LjgyOWwtMTE0Ljc1LDExNC43NWMtMjguODk4LDI4Ljg1OS00NC44MSw2Ny4zMDEtNDQuODEsMTA4LjE1MgoJCQkJYzAsNTIuMzA3LDI2LjM3NCwxMDAuNDYzLDcwLjU3MSwxMjguODA3YzYuNjk0LDQuMjgzLDE0LjQ5Nyw1LjQ1LDIxLjcwNywzLjg0NGM3LjEzMy0xLjU2OCwxMy42NzQtNS44NzEsMTcuOTM5LTEyLjUwOAoJCQkJYzQuMjg0LTYuNjkzLDUuNDUxLTE0LjQ1OCwzLjg2My0yMS42M2MtMS41NjgtNy4xNzItNS44NzEtMTMuNzUxLTEyLjUyNy0xNy45OTdjLTI3LjY1NS0xNy43NDgtNDQuMTc5LTQ3Ljg1MS00NC4xNzktODAuNTE2CgkJCQljMC0yNS41NTEsOS45NDUtNDkuNTUzLDI3Ljk5OS02Ny42MDdsMTE0Ljc1LTExNC43NUM0MDkuNDQ3LDY3LjMyLDQzMy40NjgsNTcuMzc1LDQ1OSw1Ny4zNzUKCQkJCWM1Mi43MjgsMCw5NS42MjUsNDIuODk3LDk1LjYyNSw5NS42MDZjMCwyNS41NTEtOS45NDUsNDkuNTUzLTI3Ljk5OSw2Ny42MDdsLTU0LjQzLDU0LjQzYy01LjczNyw1LjczNy04LjUzLDEzLjI5Mi04LjQxNSwyMC44MDgKCQkJCWMwLjEzNCw3LjE3MiwyLjkyNiwxNC4yODcsOC40MTUsMTkuNzU2YzUuNjA0LDUuNjA0LDEyLjk0Nyw4LjM5NiwyMC4yOTIsOC4zOTZjNy4zNDQsMCwxNC42ODgtMi43OTIsMjAuMjcyLTguMzk2bDU0LjQzLTU0LjQ0OQoJCQkJQzU5Ni4wODgsMjMyLjI5Miw2MTIsMTkzLjg1MSw2MTIsMTUyLjk4MUM2MTIsNjguNjQsNTQzLjM2LDAsNDU5LDB6Ii8+CgkJPC9nPgoJPC9nPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+Cjwvc3ZnPgo=) 0 no-repeat;background-size:.7em;color:#000;padding-left:1em;border-radius:2px;text-decoration:none}a:focus,a:hover{color:#000;outline-width:0;text-decoration:underline}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt","kern"}img{max-width:100%;margin:0 0 1.45rem;padding:0}h1{font-size:2.25rem}h1,h2{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{margin:0 0 1.45rem 1.45rem;padding:0;list-style-position:outside;list-style-image:none}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{padding:0;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}pre,table{margin:0 0 1.45rem}table{padding:0;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{margin:0 0 calc(1.45rem - 1px);padding:0;background:rgba(0,0,0,.2);border:none;height:1px}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:0;padding-top:.2em;padding-bottom:.2em}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="578340677"><!-- react-empty: 2 --><div class="row" style="background:#333;margin-bottom:0px;" data-reactid="3"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;" data-reactid="4"><h1 style="margin:0;" data-reactid="5"><a style="color:white;text-decoration:none;" href="/" data-reactid="6">Simars.io</a></h1></div></div><nav style="background:#f4f4f4;padding-top:10px;" data-reactid="7"><ul style="list-style:none;display:flex;justify-content:space-evenly;" data-reactid="8"><li data-reactid="9"><a href="/" data-reactid="10">Home</a></li><li data-reactid="11"><a href="/about" data-reactid="12">About</a></li><li data-reactid="13"><a href="/blog" data-reactid="14">Blog</a></li></ul></nav><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0;" data-reactid="15"><div data-reactid="16"><a href="/blog" data-reactid="17">Go Back</a><hr data-reactid="18"/><h1 data-reactid="19">Testing Angular Components | Shallow and Deep</h1><h4 data-reactid="20"><!-- react-text: 21 -->Posted by <!-- /react-text --><!-- react-text: 22 -->Simar Paul Singh<!-- /react-text --><!-- react-text: 23 --> on <!-- /react-text --><!-- react-text: 24 -->2018-10-01<!-- /react-text --></h4><div data-reactid="25"><hr>
<p>Typical <strong>Angular</strong> application renders and interacts with set of <strong><em>Container</em></strong> <em>(Smart / Stateful)</em> components, containing one or more re-usable <strong><em>Presentation</em></strong> <em>(Dumb / Stateless)</em> components.</p>
<p><strong><strong>Services</strong></strong> contain <em>Business Logic</em>. <strong><em>Pipes</em></strong> and <strong><em>Store Selectors</em></strong> contain <em>Re-usable Transformers / Data Logic</em>. </p>
<p><strong><strong>Model / State</strong></strong>  should be in <em>Store</em>. <em>Ngrx</em> is commonly used for store and state management with <em>reducers</em> and <em>effects</em> handling state selection and mutations.</p>
<p><strong><em>Container</em></strong> <em>components</em> are responsible for wiring up, <em>Services</em>, data to/from <em>Store</em> pass in <code>@Input()</code> data to <strong><em>Presentation</em></strong> <em>components</em> for rendering and process <code>@Output()</code> from handed / emitted event(s).</p>
<p><em>Services, Pipes , Store (Reducers &#x26; Selectors)</em> are usually straight forward to <em>unit test</em> as they don't involve any DOM <em>rendering</em> or <em>event-handling</em></p>
<p>Unit Testing <strong><em>Container</em></strong> <em>Components</em> must be done at 2 levels, <strong>Shallow Test</strong> and <strong>Deep Test</strong>, to test any direct rendering / event-handling done by container component, then its wiring to contained presentation components respectively.</p>
<p>Consider an example <code>&#x3C;Details-Container/></code> component is a container component, responsible for providing and / or managing state <code>details</code>, (ex. using ngrx store, state selectors and/or actions).
It contains a presentation components <code>&#x3C;Contact-Presentation/></code>, which receive <code>contact</code> data as <code>@Input()</code> property for rendering, and <em>emits</em> <code>(onAdd)</code> event when user clicks on a <em>Add to my Contacts</em> <code>&#x3C;button/></code>.</p>
<pre><code>import { Component } from '@angular/core';
import { select, Store } from '@ngrx/store';


@Component({
  'selector': 'Details-Container',
  'template': `&#x3C;Details-Container *ngIf='details$ | async as details'>

    &#x3C;h3>{{details.title}}&#x3C;/h3>
    &#x3C;p>{{details.description}}&#x3C;/p>

       &#x3C;Location-Presentation [location]='details.address'/>
       &#x3C;Contact-Presentation 
         [contact]='details.contact'
         (onAdd)='addContact($event)'
       />
    &#x3C;/DetailsPage-Container>`
})
export class DetailsContainerComponent {

  details$: Observable&#x3C;any>;
  
  constructor(private store: Store&#x3C;any>) {
    this.details$ = store.pipe(select(getDetailsSelector));
  }
  
  addContact(contactId: number) {
    this.store.dispatch({ 
      type: 'add_my_contact', 
      payload: contactId  
     } : ActionWithPayload&#x3C;number>)
  }

}
</code></pre>
<pre><code>import { Component, Input, Output EventEmitter } from '@angular/core';

@Component({
  'selector': 'Contact-Presentation',
  'template': `&#x3C;span> 
      &#x3C;strong> {{contact.firstName}} |&#x3C;/strong>  
      &#x3C;a href='mailto'> {{contact.email}} &#x3C;/a>
      &#x3C;button (click)='this.onAdd.emit(contact.id)'>
        Add to My Contacts 
      &#x3C;/button>
    &#x3C;/span>`
})
export class DetailsContainerComponent {
  @Input() contact: {firstName: string, email?: string, id: number};
  @Output() ontAdd = new EventEmitter&#x3C;number>(); 
}
</code></pre>
<h2>Testing Angular Components</h2>
<h3>Shallow Test</h3>
<p>Our Objective in <strong>Shallow Test(s)</strong> is to assert <em>Container Component render stuff it is responsible for rendering properly</em>.</p>
<p>Its usual that we write our <em>Container component</em> before we figure out which presentation components to re-use or create to abstract away the DOM handling.</p>
<p>Therefore for TDD its important for us to write unit tests for the container component ignoring all inner components at first if any to focus on the testing the containing component in isolation.</p>
<p>The trick here is to configure <code>TestBed</code> with only <code>declarations: [DetailsContainerComponent]</code>
Avoid the the contained presentation components with <code>schemas: [NO_ERRORS_SCHEMA, CUSTOM_ELEMENTS_SCHEMA]</code></p>
<ol>
<li><code>&#x3C;Details-Container/></code> instantiates properly.</li>
<li><code>&#x3C;Details-Container/></code>, selects <code>details</code> data from store (it could be <code>ActivatedRoute</code> , some <em>service</em>, etc)</li>
<li><code>&#x3C;Details-Container/></code> renders <code>details.title</code> and <code>details.description</code>, re-renders with changes on change detection</li>
</ol>
<pre><code>import { TestBed, async } from '@angular/core/testing';
import { RouterTestingModule } from '@angular/router/testing';
import { DetailsContainerComponent } from './details.component';
import { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import { BehaviourSubject } from 'rxjs';
import { select, Store } from '@ngrx/store';


describe('DetailsContainerComponent', () => {

  let details: any;
  let details$: BehaviourSubject&#x3C;any>;
  let store;
  let fixture: ComponentFixture&#x3C;DetailsContainerComponent>;
  let comp: ContainerComponent;

  beforeEach(async(() => {
    details = {
     title: 'This is a test title',
     description: 'This is a test description`
     contact: {
       id: 1,
       name: 'Simar',
       email: 'simar@simar.simar'
     }
    };

    details$ = new BehaviourSubject&#x3C;any>(details);

    TestBed.configureTestingModule({
      declarations: [
        DetailsContainerComponent
      ],
      providers: [
        provide: Store,
        useValue: {
          pipe: jasmine.createSpy('pipe').and.return(details$)},
          dispatch: jasmine.createSpy('dispatch')
        }
      ],
      schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA]
    }).compileComponents();
    fixture = TestBed.createComponent(DetailsContainerComponent);
    comp = fixture.debugElement.componentInstance;
  }));

  it('should create the comp', async(() => {
    expect(comp).toBeTruthy();
  }));

  it('should select details from store', async(() => {
    expect(store.pipw).toHaveBeenCallWith(select(getContainerDetails));
    expect(comp.details$).subscribe((d)=> expect(d).toBe(details)); // without jasmine marbles
    expect(comp.details$).toBeObsevable('(a|)', {a: details}); // with jasmine marbles
  }));

  it('should render title in a h3 tag', async(() => {
    fixture.detectChanges();
    const compiled = fixture.debugElement.nativeElement;
    expect(compiled.querySelector('h3').textContent).toContain(details.title);
    const title = 'Changed Title';
    details$.next({...details, title});
    fixture.detectChanges();
    expect(compiled.querySelector('h3').textContent).toContain(changedTitle);
  }));

  it('should render description in a p tag', async(() => {
    fixture.detectChanges();
    const compiled = fixture.debugElement.nativeElement;
    const description = 'Changed Description'
    details.next({...details, description});
    fixture.detectChanges();
    expect(compiled.querySelector('p').textContent).toContain(description);
  }));

});
</code></pre>
<h3>Deep Test</h3>
<p>Our Objective in <strong>Deep Test(s)</strong> is to assert <em>Interactions of Container Component with presentation Components, store, and any services if any</em>.</p>
<ol>
<li><code>&#x3C;Container-Details\></code> passes the correct <code>@Input() contact</code> = <code>details.location</code> to <code>&#x3C;Location-Contact/></code></li>
<li><code>&#x3C;Container-Details\></code> can receive <code>(onAdd)</code> event from <code>&#x3C;Presentation-Contact/></code> &#x26; react by dispatching <code>add-my-contact</code> action to <code>Store</code></li>
</ol>
<pre><code>import { TestBed, async } from '@angular/core/testing';
import { RouterTestingModule } from '@angular/router/testing';
import { DetailsContainerComponent } from './details.component';
import { Store } from '@ngrx/store';
import { BehaviourSubject } from 'rxjs';
import { select, Store } from '@ngrx/store';


describe('DetailsContainerComponent', () => {

  let details : any;
  let details$: BehaviourSubject&#x3C;any>;
  let store;
  let fixture: ComponentFixture&#x3C;DetailsContainerComponent>;
  let comp: ContainerComponent;

  beforeEach(async(() => {
    details = {
     title: 'This is a test title',
     description: 'This is a test description`
     contact: {
       id: 1,
       name: 'Simar',
       email: 'simar@simar.simar'
     }
    };
    
    details$ = new BehaviourSubject&#x3C;any>(details);
    
    TestBed.configureTestingModule({
      declarations: [
        DetailsContainerComponent
      ],
      providers: [
        provide: Store,
        useValue: {
          pipe: jasmine.createSpy('pipe').and.return(details$)},
          dispatch: jasmine.createSpy('dispatch')
        }
      ]
    }).compileComponents();
    fixture = TestBed.createComponent(DetailsContainerComponent);
    comp = fixture.debugElement.componentInstance;
  }));

  it('should pass contact.details as inpiut to &#x3C;Contact-Presentation/>', async(() => {
    fixture.detectChanges();
    const contactComp = fixture.debugElement.query(By.css('Contact-Presentation'));
    expect(contactComp).toBeTruhty();
    expect(contactComp.contact).toEqual(details.contact);
    const contact = { firstName: 'Paul', email: 'paul@paul.com' }
    details.next({...details, contact});
    fixture.detectChanges();
    expect(contactComp.contact).toEqual(contact);
  }));

  it('should listen to onAdd() event from &#x3C;Contact-Presentation/>', async(() => {
    fixture.detectChanges();
    const contactComp = fixture.debugElement.query(By.css('Contact-Presentation'));
    expect(contactComp).toBeTruhty();
    spyOn(comp,'addContact').and.callThrough();
    const contactId = 10;
    contactComp.onAdd.emit(contactId);
    expect(comp.addContact).toHaveBeenCalledWith(contactId);
    expect(store.dispatch).toHaveBeenCalledWith({
        type: 'add_my_contact',
        payload: 10
      } : ActionWithPayload&#x3C;number>);
  }));

});
</code></pre>
<h3>How deep should we test?</h3>
<p>We can always test the rendering and event handling of inner components in deep tests for container components.
However, that is necessary if we are not writing any shallow tests for those inner components.
Assuming we write shallow tests for all component, writing deep tests for container components to just test the interactions is reasonable.</p>
<p>Let us consider we don't have a shallow test for <code>&#x3C;Contact-Presentation></code>, and we don't need writing one as it is not going to be used anywhere other than <code>&#x3C;Details-Container></code>
We could re-write the last two tests as follows.</p>
<pre><code>  it('should pass contact.details as inpiut to &#x3C;Contact-Presentation/>', async(() => {
    fixture.detectChanges();
    const contactComp = fixture.debugElement.query(By.css('Contact-Presentation'));
    expect(contactComp).toBeTruhty();
    const contactEl = contactComp.nativeElement;
    // check rendering on contact element
    expect(contactEl.querySelector('strong').textContent).toContain(details.contact.firstName);
    expect(contactEl.querySelector('a').textContent).toContain(details.contact.email);
    const contact = { firstName: 'Paul', email: 'paul@paul.com' }
    details.next({...details, contact});
    fixture.detectChanges();
    expect(contactEl.querySelector('strong').textContent).toContain(contact.firstName);
    expect(contactEl.querySelector('a').textContent).toContain(contact.email);
  }));

  it('should listen to onAdd() event from &#x3C;Contact-Presentation/>', async(() => {
    fixture.detectChanges();
    const contactComp = fixture.debugElement.query(By.css('Contact-Presentation'));
    expect(contactComp).toBeTruhty();
    spyOn(comp,'addContact').and.callThrough();
    const contactId = 10;
    // click event triggerred from contact elemnt button
    contactComp.nativeElement.querySelector('button').click();
    expect(comp.addContact).toHaveBeenCalledWith(contactId);
    expect(store.dispatch).toHaveBeenCalledWith({
        type: 'add_my_contact',
        payload: 10
      } : ActionWithPayload&#x3C;number>);
  }));
</code></pre>
<p>Its more <em>maintainable</em> to test <em>DOM rendering and event handling</em> of <code>&#x3C;Contact-Presentation/></code> its own spec and not have the same tests in the <code>&#x3C;Details-Container/></code></p>
<p><strong><em>Presentation</em></strong> <em>components</em> are re-usable and may be used by many other components. It becomes a maintenance overhead when the same component for same cases gets tested in many different places.</p>
<p>If you are concerned about how the whole component tree's render, <strong>E2E</strong> <em>(End to End Testing)</em> tests are a better solution than complicating our deep tests for containers.</p>
<p>Check out <strong><a href="https://github.com/angular/protractor">Protractor</a></strong> , a popular framework / tool for Angular <em>end to end testing</em> <strong>E2E</strong> .</p>
<p><strong>Shallow</strong> and <strong>Deep Tests</strong> fall under <strong>unit testing</strong> which are much easier to write, run faster and are self-contained making them more maintainable than <strong>E2E</strong> tests</p>
<p><strong>E2E</strong> tests are great for high-level validation of the entire system. But they can't give you the comprehensive test coverage that you'd expect from <strong>unit tests</strong>.</p></div></div></div></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-28a5d26ae4a6a7b6ddd4.js","107818501498521":"component---src-templates-blog-post-js-0668ad1c8e9fa38db975.js","162898551421021":"component---src-pages-404-js-4503918ea3a16cfcdb75.js","263791100135453":"component---src-pages-about-js-e690ab7fd7ee2309d07b.js","212839066777427":"component---src-pages-blog-js-708eb757a32e0c281fdb.js","35783957827783":"component---src-pages-index-js-89bc171a520e1f135c69.js","60335399758886":"path----6bb8d3498a44ed0a3478.js","371127763309":"path---improve-ngfor-usability-and-performance-with-trackby-aed135a3ae2714ff3ab8.js","86583290751729":"path---create-generic-angular-pipes-apply-and-applypure-6af8278fe681b6155884.js","45993978181358":"path---custom-transitive-validators-in-reactive-forms-angular-060dfbc7141ff35833e2.js","223480463421619":"path---manage-scrolls-on-router-outlets-angular-83a757871103bf34b8a4.js","190868841189419":"path---testing-angular-directives-with-test-component-75292d6f19da6a9f7ee5.js","111883881408753":"path---kotlin-extension-functions-make-any-class-have-what-you-wish-for-9938a3379691036481ef.js","274223600717461":"path---angular-test-components-unit-shallow-deep-177aca4874a2ff4db95f.js","254022195166212":"path---404-a0e39f21c11f6a62c5ab.js","273950069227526":"path---about-a0e39f21c11f6a62c5ab.js","49683490770531":"path---blog-27af295f76803b3831c0.js","142629428675168":"path---index-27af295f76803b3831c0.js","178698757827068":"path---404-html-a0e39f21c11f6a62c5ab.js","114276838955818":"component---src-layouts-index-js-666f50598e70c7b6e5d1.js"}/*]]>*/</script><script>/*<![CDATA[*/!function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",["/commons-403258ad126d5c26671b.js","/app-28a5d26ae4a6a7b6ddd4.js","/path---angular-test-components-unit-shallow-deep-177aca4874a2ff4db95f.js","/component---src-templates-blog-post-js-0668ad1c8e9fa38db975.js","/component---src-layouts-index-js-666f50598e70c7b6e5d1.js"])/*]]>*/</script></body></html>