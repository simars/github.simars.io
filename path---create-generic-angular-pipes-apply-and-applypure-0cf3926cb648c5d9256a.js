webpackJsonp([86583290751729],{333:function(e,n){e.exports={data:{markdownRemark:{html:'<hr>\n<h3>Fulfill your pipe dream in templates</h3>\n<ol>\n<li>Keep one-off (non-reusable) transform impure functions in components, pass them as value-argument to be applied</li>\n<li>Define your re-usable pure functions separately, and import them in components as needed and pass them as value-argument to be applied</li>\n</ol>\n<p>For source click on <a href="https://github.com/simars/ngx-mix-libraries/blob/master/projects/ngx-mix/src/lib/pipe/apply"><strong>[GitHub]</strong></a> &#x26; To Tryout click on <strong>[</strong><a href="https://codepen.io/simars/pen/wxRpjN/"><strong>CodePen</strong></a><strong>]</strong></p>\n<pre name="991f" id="991f" class="graf graf--pre graf-after--p">import { Pipe, PipeTransform } from \'@angular/core\';  \n\n@Pipe({  \n  name: \'applyPure\',  \n  pure: true // immutable (value) inputs & pure fn (function)  \n})  \nexport class ApplyPurePipe implements PipeTransform {  \n\n  transform(value: any, fn: Function): any {  \n    return fn(value);  \n  }  \n}  \n\n@Pipe({  \n  name: \'apply\',  \n  pure: false // any (value) inputs & any fn (function)  \n})  \nexport class ApplyPipe implements PipeTransform {  \n\n  transform(value: any, fn: Function): any {  \n    return fn(value);  \n  }  \n\n}</pre>\n<p>Write your functions in components, and pass the function itself as pipe value-arg to be applied</p>\n<pre name="3e4b" id="3e4b" class="graf graf--pre graf-after--p">[@Component](http://twitter.com/Component "Twitter profile for @Component")({  \n  selector: \'my-app\',  \n  template: `<p>SUM of {{fib | json}} = {{fib | apply: sum}}</p>`  \n})  \nclass AppComponent  {</pre>\n<pre name="ab3e" id="ab3e" class="graf graf--pre graf-after--pre">fib = [1, 2, 3, 5, 8];</pre>\n<pre name="7983" id="7983" class="graf graf--pre graf-after--pre">public sum(collection: [number]): number {  \n    return collection.reduce((first, second) => first + second);  \n  }  \n\n}</pre>\n<h3>Why do we need two kinds (apply &#x26; applyPure)?</h3>\n<p><strong>Pure pipes leverage</strong> many advantages which come with <a href="https://en.wikipedia.org/wiki/Pure_function"><strong>Pure functions</strong></a></p>\n<ol>\n<li>First pure pipes <strong>evaluate only when input changes</strong>, second they <strong>cache the outputs for previously evaluated inputs</strong>, and can bind the result from cache <strong>without re-evaluating the pipe expression if the same input was previously evaluated</strong>.</li>\n<li><strong>Single instance</strong> of a pure pipe is used for all bindings in the app, across components</li>\n<li><strong>Just need to test transform function</strong>, known input to known output.</li>\n</ol>\n<p><strong>Impure pipes</strong> can’t leverage caching, instance re-use and simple tests</p>\n<h3><strong>When should we declare a Pipe as {pure: false}</strong>?</h3>\n<ol>\n<li>Either, the transform function they are evaluating isn’t pure.</li>\n<li>Or, there is no way to identify or differentiate between different inputs.</li>\n</ol>\n<p>(1) is obvious but (2) is something easy to trip over. Let us see it with examples</p>\n</div>\n</div>\n</section>',frontmatter:{path:"/create-generic-angular-pipes-apply-and-applypure",title:"Create Generic Angular Pipes | apply and applyPure",author:"Simar Paul Singh",date:"2018-04-22"}}},pathContext:{}}}});
//# sourceMappingURL=path---create-generic-angular-pipes-apply-and-applypure-0cf3926cb648c5d9256a.js.map