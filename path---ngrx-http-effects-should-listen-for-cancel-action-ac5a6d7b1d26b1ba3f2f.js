webpackJsonp([29526849648376],{350:function(e,n){e.exports={data:{markdownRemark:{html:"<p>In a <strong>Ngrx</strong> implementation, a Store Effect loads an entity from from REST APIs when it receives a <code>FETCH_ENTITIES</code> action and then dispatch a <code>FETCHED_ENTITIES</code> action with payload for reducers to merge them in Store.</p>\n<pre><code>import {Injectable} from '@angular/core';\nimport {Actions, Effect, ofType} from '@ngrx/effects';\nimport {catchError, switchMap, map} from 'rxjs/operators';\nimport {of} from 'rxjs';\nimport {EntityService} from './';\n\n@Injectable()\nexport class Effects {\n\n  constructor(\n    private actions$: Actions,\n    private enService: EntityService,\n    private store: Store&#x3C;{entities: any[]}>\n  ) {}\n\n  @Effect()\n  getUsers$ = this.actions$.pipe(\n  ofType('FETCH_ENTITIES', 'CANCEL_FETCH_ENTITIES'),\n  .switchMap(action => action.type === 'CANCEL_FETCH_ENTITIES' ?\n    of() :\n    this.enService.getEntities().pipe(\n      map(users => ({type: 'FETCHED_ENTITIES', entity})),\n      catchError(error => of( {type: 'ERROR', error}))\n      )\n    )\n  );\n}\n</code></pre>\n<p>If you notice, the same effect now listens to both <code>ofType(‘FETCH_ENTITIES’, ‘CANCEL_FETCH_ENTITIES’)</code> actions. It can now switch an ongoing <code>this.getEntities()</code> <em>Observable</em> for <code>of()</code> . Upon <code>CANCEL_FETCH_ENTITIES</code> We could also return <code>of({type:'FETCHED_ENTITIES_ACTION, []})</code> depending on what reducing layer expects. However the main point is since we are using <code>switchMap(…)</code> to switch to a different Observable upon <code>CANCEL_FETCH_ENTITIES</code> it will unsubscribe the the previously emitted <code>this.getEntities()</code> <em>http$</em> observable and when the <em>http$</em> observable is unsubscribed will cancel any ongoing requests.</p>\n<pre><code>import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n@Injectable()\nexport class EntityService {\n  constructor(private http: HttpClient) { }\n\n  getEntities() {\n   return this.http.get&#x3C;any[]>('/api/entities');\n  }\n}\n</code></pre>\n<p>To learn more about cancel / abort works on an <em>http</em> requests running inside an <code>http&#x3C;div class=\"section-inner sectionLayout--insetColumn\" on</code>http$.unsubscribe()` checkout <strong><a href=\"/rxjs-create_custom_observables_from_event_sources\">Custom Observables from Event Sources</a></strong>.</p>\n<p>Now that our effect processes both <code>ofType(‘FETCH_ENTITIES’, ‘CANCEL_FETCH_ENTITIES’)</code> actions, when should we emit <code>CANCEL_FETCH_ENTITIES</code> ?</p>\n<p>It depends, sometimes with an explicit user-case where a user clicks on a <code>&#x3C;button (click)=”cancel()”>Cancel&#x3C;/button></code>, to cancel an operation. Trickier one’s are implicit, like when we navigate away and a component which dispatched <code>FETCH_ENTITIES</code> action is getting destroyed.</p>\n<pre><code>import {select, Store} from '@ngrx/store';\nimport {Component, OnInit, OnDestroy} from '@angular/core';\n@Component({\n  selector: 'some-comp',\n  template: `\n  &#x3C;ng-container *ngIf=\"en$ | async en; else #loading \">\n   {{en | json}}\n  &#x3C;/ng-container>\n  &#x3C;ng-template #loading>\n     &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n  &#x3C;/ng-template>\n`\n})\nexport class SomeComponent implements OnInit, OnDestroy {\n   en$: Observable&#x3C;any[]>;\n   constructor(store: Store) {\n     this.en$ = this.store.select('entities');\n   }\n   cancel() {\n    this.store.dispatch({type: 'CANCEL_FETCH_ENTITIES'});\n   }\n\n   ngOnInit() {\n      this.store.dispatch({type: 'FETCH_ENTITIES'});\n   }\n   ngOnDestroy() {\n     this.cancel();\n   }\n\n}\n</code></pre>",frontmatter:{path:"/ngrx-http-effects-should-listen-for-cancel-action",title:"Ngrx http$ Effects should listen for CANCEL action",author:"Simar Paul Singh",date:"2018-10-05"}}},pathContext:{}}}});
//# sourceMappingURL=path---ngrx-http-effects-should-listen-for-cancel-action-ac5a6d7b1d26b1ba3f2f.js.map