webpackJsonp([45993978181358],{334:function(e,r){e.exports={data:{markdownRemark:{html:'<hr>\n<p>Advantages of <strong>Reactive</strong> <strong>Forms</strong> over Template Driven Forms stem from the fact, controls are defined in <strong>Component</strong> <strong>programmatically</strong> and assigned to form and its inputs in <strong>Template declaratively</strong></p>\n<p>This makes adding controls dynamically with <code>FormArray</code>, reacting to events with RxJs, Unit testing sans <code>Template</code> all easier with code in component driving the logic, over html directives and /or pipes handling the same in template / dom.</p>\n<p>However, there are aspects to form handling, in particular field validation and respective error messages that are more convenient in templates.</p>\n<p>For example, if a field <em>(email)</em> is required only when <em>field (phone)</em> is not filled in, *<code>ngIf</code> can simply remove or disable the unrequited <em>field (email)</em> from the DOM, and put it back as a required field based on the <em>field (phone)</em> value.</p>\n<pre name="d2c5" id="d2c5" class="graf graf--pre graf-after--p"><form #ngForm="f" (ngSubmit)="f.valid && onSubmit(f)" novalidate>  \n <label>   \n    Phone <input name="phone" #ngModel="phone"   pattern="[0-9]{9}">  \n </label>  \n <label> `*ngIf="phone.errors.pattern">   \n   Phone Number should be digits  \n </label>`</pre>\n<pre name="2b32" id="2b32" class="graf graf--pre graf-after--pre"><label>   \n   Email <input name="email" #ngModel="email">  \n </label>  \n <label> `*ngIf="`phone?.value?.length || email.value?.length`">   \n   Email is required if phone number is not given  \n </label>`  \n <button type="submit\'  \n  [disabled]= "!f.valid || (!phone.value?.length && !email.value?.length)">Submit</button></pre>\n<pre name="8ce0" id="8ce0" class="graf graf--pre graf-after--pre"></form></pre>\n<p>In reactive form setup, having <code>*ngIf</code> ain’t going to do any good. The form controls in form group, controlling form’s fields are decoupled from template DOM by design.</p>\n<p>In a reactive form setup even If an *ngIf disables a required input in template DOM, an event must be handled in component to instrument the FormGroup’s contol declared for this input.</p>\n<p><strong>So how can we do declarative style validations in Reactive Forms</strong>?</p>\n<h3>Built in Angular input validators</h3>\n<p>Angular has handful of built in validaitors we could use in our <code>FormGroupBuilder</code> to match the basic HTML 5 validators we use use in templates / DOM (<code>required</code>,<code>minLength</code>,<code>maxLength</code>,<code>pattern</code>,<code>email</code> ).</p>\n<p>A special one <code>compose</code>: is used when more than one validation is needed for the same form field.</p>\n<p>A <strong>limitation</strong> here is, there is <strong>no transitive / cross field validation</strong> built-in where state of one field effects the other. We need custom group level validators, which we can build in a reusable pattern.</p>\n<h3>How to Build reusable custom Cross-Field / Transitive validations</h3>\n<p>Checkout the full implementation by clicking <a href="https://codepen.io/simars/pen/ZMYxrm">[CodePen]</a></p>\n<p>Let consider possible relationships between Field-1 with Field-2, there are 3 possible cases.</p>\n<p>1. Field-1 is required only when Field-2 is given or vice-versa</p>\n<p>2. Field-1 is not required when Field-2 is given or vice-versa</p>\n<p>3. Either of Field-1 or Field-2 are required.</p>\n<p>If Both fields are required, there isn’t any relationship, simply both are Validation.required at their respective field levels.</p>\n<p>This is how we can build a reusable Custom validates for each of these cases.</p>\n<pre name="a34e" id="a34e" class="graf graf--pre graf-after--p">class CustomValidators {  \n\n  static requiredWhen(requiredControlName, controlToCheckName) {  \n    return (control: AbstractControl) => {  \n      const required = control.get(requiredControlName);  \n      const toCheck = control.get(controlToCheckName);  \n      if (required.value || !toCheck.value) {  \n        removeErrors([\'required\'], required);  \n        return null;  \n      }  \n      const errorValue = `${requiredControlName}_Required_When_${controlToCheckName}`;  \n      setErrors({required: errorValue}, required);  \n      return {[errorValue]: true};  \n    };  \n  }</pre>\n<pre name="20ef" id="20ef" class="graf graf--pre graf-after--pre">static requiredEither(requiredControlName, controlToCheckName) {  \n    return (control) => {  \n      const required = control.get(requiredControlName);  \n      const toCheck = control.get(controlToCheckName);  \n      if (required.value || toCheck.value) {  \n        removeErrors([\'required\'], required);  \n        removeErrors([\'required\'], toCheck);  \n        return null;  \n      }  \n      const errorValue = `${requiredControlName}_Required_Either_${controlToCheckName}`;  \n      setErrors({required: errorValue}, required);  \n      setErrors({required: errorValue}, toCheck);  \n      return {[errorValue]: true};  \n    };  \n  }</pre>\n<pre name="5e9f" id="5e9f" class="graf graf--pre graf-after--pre">static requiredWhenNot(requiredControlName, controlToCheckName) {  \n    return (control) => {  \n      const required = control.get(requiredControlName);  \n      const toCheck = control.get(controlToCheckName);  \n      if (required.value || toCheck.value) {  \n        removeErrors([\'required\'], required);  \n        return null;  \n      }  \n      const errorValue = `${requiredControlName}_Required_When_Not_${controlToCheckName}`;  \n      setErrors({required: errorValue}, required);  \n      return  {[errorValue]: true};  \n    };  \n  }</pre>\n<pre name="6a83" id="6a83" class="graf graf--pre graf-after--pre">}</pre>\n<pre name="8f05" id="8f05" class="graf graf--pre graf-after--pre">function setErrors(error: {[key: string]: any }, control: AbstractControl) {  \n  control.setErrors({...control.errors, ...error});  \n}</pre>\n<pre name="54a1" id="54a1" class="graf graf--pre graf-after--pre">function  removeErrors(keys: string[], control: AbstractControl) {  \n  const remainingErrors = keys.reduce((errors, key) => {  \n    delete  errors[key];  \n    return errors;  \n  }, {...control.errors});  \n  control.setErrors(Object.keys(remainingErrors).length > 0 ? remainingErrors : null);  \n}</pre>\n<p>Use them declarively in your your FromBuilder group definations.</p>\n<pre name="abff" id="abff" class="graf graf--pre graf-after--p">class AppComponent implements OnInit  {</pre>\n<pre name="040f" id="040f" class="graf graf--pre graf-after--pre">registerForm: FormGroup;  \n    submitted = false;  \n\n  constructor( [@Inject](http://twitter.com/Inject "Twitter profile for @Inject")(FormBuilder) private formBuilder: FormBuilder) {}</pre>\n<pre name="dbfe" id="dbfe" class="graf graf--pre graf-after--pre">ngOnInit() {  \n        this.registerForm = this.formBuilder.group({  \n            firstName: [\'\', Validators.required],  \n            phone: [\'\', [Validators.pattern(\'[0-9]*\')]],  \n            email: [\'\', [ Validators.email]]  \n        },  \n        {  \n          validator: [  \n            CustomValidators.requiredEither(\'email\', \'phone\')  \n          ]  \n        }                                             \n       );  \n    }  \n\n    // convenience getter for easy access to form fields  \n    get f() { return this.registerForm.controls; }  \n\n    onSubmit() {  \n        this.submitted = true;  \n\n        // stop here if form is invalid  \n        if (this.registerForm.invalid) {  \n            return;  \n        }  \n        alert(`Submitted -> ${JSON.stringify(this.registerForm.value)}`);  \n    }</pre>\n<pre name="2459" id="2459" class="graf graf--pre graf-after--pre">}</pre>\n<p>Template just reacts to validation control</p>\n<pre name="4ad8" id="4ad8" class="graf graf--pre graf-after--p"><form [formGroup]="registerForm" (ngSubmit)="onSubmit()">  \n <label>   \n    Phone <input formControlName="phone">  \n </label>  \n <div *ngIf="f.phone.errors" class="invalid-feedback">  \n    <div *ngIf="f.phone.errors.required">  \n     Phone number is required if email is not given.</div>  \n     <div *ngIf="f.phone.errors.pattern">  \n     Phone number must match pattern digits</div>  \n </div></pre>\n<pre name="4f4c" id="4f4c" class="graf graf--pre graf-after--pre"><label>   \n   Email <input formControlName="email">  \n </label>  \n <div *ngIf="f.email.errors">  \n    <div *ngIf="f.email.errors.required">  \n    Email is required ({{f.email.errors.required}}).  \n    </div>  \n    <div *ngIf="f.email.errors.email">  \n    Email must be a valid email address  \n    </div>                          \n</div></pre>\n<pre name="6adf" id="6adf" class="graf graf--pre graf-after--pre"><button [disabled]="registerForm.invalid" type="submit">  \n Register  \n</button></pre>\n<pre name="73df" id="73df" class="graf graf--pre graf-after--pre"></form></pre>\n<p>Checkout full working code at <a href="https://codepen.io/simars/pen/ZMYxrm">https://codepen.io/simars/pen/ZMYxrm</a></p>',frontmatter:{path:"/custom-transitive-validators-in-reactive-forms-angular",title:"Build {Cross-field / Transitive Validators} for {Reactive Forms} | Angular",author:"Simar Paul Singh",date:"2018-05-07"}}},pathContext:{}}}});
//# sourceMappingURL=path---custom-transitive-validators-in-reactive-forms-angular-d4d23279473d16cd1c16.js.map