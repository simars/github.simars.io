{"version":3,"sources":["webpack:///path---custom-transitive-validators-in-reactive-forms-angular-d4d23279473d16cd1c16.js","webpack:///./.cache/json/custom-transitive-validators-in-reactive-forms-angular.json"],"names":["webpackJsonp","334","module","exports","data","markdownRemark","html","frontmatter","path","title","author","date","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,w4RAAy/QC,aAA2iBC,KAAA,0DAAAC,MAAA,6EAA0IC,OAAA,mBAAAC,KAAA,gBAA8DC","file":"path---custom-transitive-validators-in-reactive-forms-angular-d4d23279473d16cd1c16.js","sourcesContent":["webpackJsonp([45993978181358],{\n\n/***/ 334:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<hr>\\n<p>Advantages of <strong>Reactive</strong> <strong>Forms</strong> over Template Driven Forms stem from the fact, controls are defined in <strong>Component</strong> <strong>programmatically</strong> and assigned to form and its inputs in <strong>Template declaratively</strong></p>\\n<p>This makes adding controls dynamically with <code>FormArray</code>, reacting to events with RxJs, Unit testing sans <code>Template</code> all easier with code in component driving the logic, over html directives and /or pipes handling the same in template / dom.</p>\\n<p>However, there are aspects to form handling, in particular field validation and respective error messages that are more convenient in templates.</p>\\n<p>For example, if a field <em>(email)</em> is required only when <em>field (phone)</em> is not filled in, *<code>ngIf</code> can simply remove or disable the unrequited <em>field (email)</em> from the DOM, and put it back as a required field based on the <em>field (phone)</em> value.</p>\\n<pre name=\\\"d2c5\\\" id=\\\"d2c5\\\" class=\\\"graf graf--pre graf-after--p\\\"><form #ngForm=\\\"f\\\" (ngSubmit)=\\\"f.valid && onSubmit(f)\\\" novalidate>  \\n <label>   \\n    Phone <input name=\\\"phone\\\" #ngModel=\\\"phone\\\"   pattern=\\\"[0-9]{9}\\\">  \\n </label>  \\n <label> `*ngIf=\\\"phone.errors.pattern\\\">   \\n   Phone Number should be digits  \\n </label>`</pre>\\n<pre name=\\\"2b32\\\" id=\\\"2b32\\\" class=\\\"graf graf--pre graf-after--pre\\\"><label>   \\n   Email <input name=\\\"email\\\" #ngModel=\\\"email\\\">  \\n </label>  \\n <label> `*ngIf=\\\"`phone?.value?.length || email.value?.length`\\\">   \\n   Email is required if phone number is not given  \\n </label>`  \\n <button type=\\\"submit'  \\n  [disabled]= \\\"!f.valid || (!phone.value?.length && !email.value?.length)\\\">Submit</button></pre>\\n<pre name=\\\"8ce0\\\" id=\\\"8ce0\\\" class=\\\"graf graf--pre graf-after--pre\\\"></form></pre>\\n<p>In reactive form setup, having <code>*ngIf</code> ain’t going to do any good. The form controls in form group, controlling form’s fields are decoupled from template DOM by design.</p>\\n<p>In a reactive form setup even If an *ngIf disables a required input in template DOM, an event must be handled in component to instrument the FormGroup’s contol declared for this input.</p>\\n<p><strong>So how can we do declarative style validations in Reactive Forms</strong>?</p>\\n<h3>Built in Angular input validators</h3>\\n<p>Angular has handful of built in validaitors we could use in our <code>FormGroupBuilder</code> to match the basic HTML 5 validators we use use in templates / DOM (<code>required</code>,<code>minLength</code>,<code>maxLength</code>,<code>pattern</code>,<code>email</code> ).</p>\\n<p>A special one <code>compose</code>: is used when more than one validation is needed for the same form field.</p>\\n<p>A <strong>limitation</strong> here is, there is <strong>no transitive / cross field validation</strong> built-in where state of one field effects the other. We need custom group level validators, which we can build in a reusable pattern.</p>\\n<h3>How to Build reusable custom Cross-Field / Transitive validations</h3>\\n<p>Checkout the full implementation by clicking <a href=\\\"https://codepen.io/simars/pen/ZMYxrm\\\">[CodePen]</a></p>\\n<p>Let consider possible relationships between Field-1 with Field-2, there are 3 possible cases.</p>\\n<p>1. Field-1 is required only when Field-2 is given or vice-versa</p>\\n<p>2. Field-1 is not required when Field-2 is given or vice-versa</p>\\n<p>3. Either of Field-1 or Field-2 are required.</p>\\n<p>If Both fields are required, there isn’t any relationship, simply both are Validation.required at their respective field levels.</p>\\n<p>This is how we can build a reusable Custom validates for each of these cases.</p>\\n<pre name=\\\"a34e\\\" id=\\\"a34e\\\" class=\\\"graf graf--pre graf-after--p\\\">class CustomValidators {  \\n\\n  static requiredWhen(requiredControlName, controlToCheckName) {  \\n    return (control: AbstractControl) => {  \\n      const required = control.get(requiredControlName);  \\n      const toCheck = control.get(controlToCheckName);  \\n      if (required.value || !toCheck.value) {  \\n        removeErrors(['required'], required);  \\n        return null;  \\n      }  \\n      const errorValue = `${requiredControlName}_Required_When_${controlToCheckName}`;  \\n      setErrors({required: errorValue}, required);  \\n      return {[errorValue]: true};  \\n    };  \\n  }</pre>\\n<pre name=\\\"20ef\\\" id=\\\"20ef\\\" class=\\\"graf graf--pre graf-after--pre\\\">static requiredEither(requiredControlName, controlToCheckName) {  \\n    return (control) => {  \\n      const required = control.get(requiredControlName);  \\n      const toCheck = control.get(controlToCheckName);  \\n      if (required.value || toCheck.value) {  \\n        removeErrors(['required'], required);  \\n        removeErrors(['required'], toCheck);  \\n        return null;  \\n      }  \\n      const errorValue = `${requiredControlName}_Required_Either_${controlToCheckName}`;  \\n      setErrors({required: errorValue}, required);  \\n      setErrors({required: errorValue}, toCheck);  \\n      return {[errorValue]: true};  \\n    };  \\n  }</pre>\\n<pre name=\\\"5e9f\\\" id=\\\"5e9f\\\" class=\\\"graf graf--pre graf-after--pre\\\">static requiredWhenNot(requiredControlName, controlToCheckName) {  \\n    return (control) => {  \\n      const required = control.get(requiredControlName);  \\n      const toCheck = control.get(controlToCheckName);  \\n      if (required.value || toCheck.value) {  \\n        removeErrors(['required'], required);  \\n        return null;  \\n      }  \\n      const errorValue = `${requiredControlName}_Required_When_Not_${controlToCheckName}`;  \\n      setErrors({required: errorValue}, required);  \\n      return  {[errorValue]: true};  \\n    };  \\n  }</pre>\\n<pre name=\\\"6a83\\\" id=\\\"6a83\\\" class=\\\"graf graf--pre graf-after--pre\\\">}</pre>\\n<pre name=\\\"8f05\\\" id=\\\"8f05\\\" class=\\\"graf graf--pre graf-after--pre\\\">function setErrors(error: {[key: string]: any }, control: AbstractControl) {  \\n  control.setErrors({...control.errors, ...error});  \\n}</pre>\\n<pre name=\\\"54a1\\\" id=\\\"54a1\\\" class=\\\"graf graf--pre graf-after--pre\\\">function  removeErrors(keys: string[], control: AbstractControl) {  \\n  const remainingErrors = keys.reduce((errors, key) => {  \\n    delete  errors[key];  \\n    return errors;  \\n  }, {...control.errors});  \\n  control.setErrors(Object.keys(remainingErrors).length > 0 ? remainingErrors : null);  \\n}</pre>\\n<p>Use them declarively in your your FromBuilder group definations.</p>\\n<pre name=\\\"abff\\\" id=\\\"abff\\\" class=\\\"graf graf--pre graf-after--p\\\">class AppComponent implements OnInit  {</pre>\\n<pre name=\\\"040f\\\" id=\\\"040f\\\" class=\\\"graf graf--pre graf-after--pre\\\">registerForm: FormGroup;  \\n    submitted = false;  \\n\\n  constructor( [@Inject](http://twitter.com/Inject \\\"Twitter profile for @Inject\\\")(FormBuilder) private formBuilder: FormBuilder) {}</pre>\\n<pre name=\\\"dbfe\\\" id=\\\"dbfe\\\" class=\\\"graf graf--pre graf-after--pre\\\">ngOnInit() {  \\n        this.registerForm = this.formBuilder.group({  \\n            firstName: ['', Validators.required],  \\n            phone: ['', [Validators.pattern('[0-9]*')]],  \\n            email: ['', [ Validators.email]]  \\n        },  \\n        {  \\n          validator: [  \\n            CustomValidators.requiredEither('email', 'phone')  \\n          ]  \\n        }                                             \\n       );  \\n    }  \\n\\n    // convenience getter for easy access to form fields  \\n    get f() { return this.registerForm.controls; }  \\n\\n    onSubmit() {  \\n        this.submitted = true;  \\n\\n        // stop here if form is invalid  \\n        if (this.registerForm.invalid) {  \\n            return;  \\n        }  \\n        alert(`Submitted -> ${JSON.stringify(this.registerForm.value)}`);  \\n    }</pre>\\n<pre name=\\\"2459\\\" id=\\\"2459\\\" class=\\\"graf graf--pre graf-after--pre\\\">}</pre>\\n<p>Template just reacts to validation control</p>\\n<pre name=\\\"4ad8\\\" id=\\\"4ad8\\\" class=\\\"graf graf--pre graf-after--p\\\"><form [formGroup]=\\\"registerForm\\\" (ngSubmit)=\\\"onSubmit()\\\">  \\n <label>   \\n    Phone <input formControlName=\\\"phone\\\">  \\n </label>  \\n <div *ngIf=\\\"f.phone.errors\\\" class=\\\"invalid-feedback\\\">  \\n    <div *ngIf=\\\"f.phone.errors.required\\\">  \\n     Phone number is required if email is not given.</div>  \\n     <div *ngIf=\\\"f.phone.errors.pattern\\\">  \\n     Phone number must match pattern digits</div>  \\n </div></pre>\\n<pre name=\\\"4f4c\\\" id=\\\"4f4c\\\" class=\\\"graf graf--pre graf-after--pre\\\"><label>   \\n   Email <input formControlName=\\\"email\\\">  \\n </label>  \\n <div *ngIf=\\\"f.email.errors\\\">  \\n    <div *ngIf=\\\"f.email.errors.required\\\">  \\n    Email is required ({{f.email.errors.required}}).  \\n    </div>  \\n    <div *ngIf=\\\"f.email.errors.email\\\">  \\n    Email must be a valid email address  \\n    </div>                          \\n</div></pre>\\n<pre name=\\\"6adf\\\" id=\\\"6adf\\\" class=\\\"graf graf--pre graf-after--pre\\\"><button [disabled]=\\\"registerForm.invalid\\\" type=\\\"submit\\\">  \\n Register  \\n</button></pre>\\n<pre name=\\\"73df\\\" id=\\\"73df\\\" class=\\\"graf graf--pre graf-after--pre\\\"></form></pre>\\n<p>Checkout full working code at <a href=\\\"https://codepen.io/simars/pen/ZMYxrm\\\">https://codepen.io/simars/pen/ZMYxrm</a></p>\",\"frontmatter\":{\"path\":\"/custom-transitive-validators-in-reactive-forms-angular\",\"title\":\"Build {Cross-field / Transitive Validators} for {Reactive Forms} | Angular\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-05-07\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---custom-transitive-validators-in-reactive-forms-angular-d4d23279473d16cd1c16.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<hr>\\n<p>Advantages of <strong>Reactive</strong> <strong>Forms</strong> over Template Driven Forms stem from the fact, controls are defined in <strong>Component</strong> <strong>programmatically</strong> and assigned to form and its inputs in <strong>Template declaratively</strong></p>\\n<p>This makes adding controls dynamically with <code>FormArray</code>, reacting to events with RxJs, Unit testing sans <code>Template</code> all easier with code in component driving the logic, over html directives and /or pipes handling the same in template / dom.</p>\\n<p>However, there are aspects to form handling, in particular field validation and respective error messages that are more convenient in templates.</p>\\n<p>For example, if a field <em>(email)</em> is required only when <em>field (phone)</em> is not filled in, *<code>ngIf</code> can simply remove or disable the unrequited <em>field (email)</em> from the DOM, and put it back as a required field based on the <em>field (phone)</em> value.</p>\\n<pre name=\\\"d2c5\\\" id=\\\"d2c5\\\" class=\\\"graf graf--pre graf-after--p\\\"><form #ngForm=\\\"f\\\" (ngSubmit)=\\\"f.valid && onSubmit(f)\\\" novalidate>  \\n <label>   \\n    Phone <input name=\\\"phone\\\" #ngModel=\\\"phone\\\"   pattern=\\\"[0-9]{9}\\\">  \\n </label>  \\n <label> `*ngIf=\\\"phone.errors.pattern\\\">   \\n   Phone Number should be digits  \\n </label>`</pre>\\n<pre name=\\\"2b32\\\" id=\\\"2b32\\\" class=\\\"graf graf--pre graf-after--pre\\\"><label>   \\n   Email <input name=\\\"email\\\" #ngModel=\\\"email\\\">  \\n </label>  \\n <label> `*ngIf=\\\"`phone?.value?.length || email.value?.length`\\\">   \\n   Email is required if phone number is not given  \\n </label>`  \\n <button type=\\\"submit'  \\n  [disabled]= \\\"!f.valid || (!phone.value?.length && !email.value?.length)\\\">Submit</button></pre>\\n<pre name=\\\"8ce0\\\" id=\\\"8ce0\\\" class=\\\"graf graf--pre graf-after--pre\\\"></form></pre>\\n<p>In reactive form setup, having <code>*ngIf</code> ain’t going to do any good. The form controls in form group, controlling form’s fields are decoupled from template DOM by design.</p>\\n<p>In a reactive form setup even If an *ngIf disables a required input in template DOM, an event must be handled in component to instrument the FormGroup’s contol declared for this input.</p>\\n<p><strong>So how can we do declarative style validations in Reactive Forms</strong>?</p>\\n<h3>Built in Angular input validators</h3>\\n<p>Angular has handful of built in validaitors we could use in our <code>FormGroupBuilder</code> to match the basic HTML 5 validators we use use in templates / DOM (<code>required</code>,<code>minLength</code>,<code>maxLength</code>,<code>pattern</code>,<code>email</code> ).</p>\\n<p>A special one <code>compose</code>: is used when more than one validation is needed for the same form field.</p>\\n<p>A <strong>limitation</strong> here is, there is <strong>no transitive / cross field validation</strong> built-in where state of one field effects the other. We need custom group level validators, which we can build in a reusable pattern.</p>\\n<h3>How to Build reusable custom Cross-Field / Transitive validations</h3>\\n<p>Checkout the full implementation by clicking <a href=\\\"https://codepen.io/simars/pen/ZMYxrm\\\">[CodePen]</a></p>\\n<p>Let consider possible relationships between Field-1 with Field-2, there are 3 possible cases.</p>\\n<p>1. Field-1 is required only when Field-2 is given or vice-versa</p>\\n<p>2. Field-1 is not required when Field-2 is given or vice-versa</p>\\n<p>3. Either of Field-1 or Field-2 are required.</p>\\n<p>If Both fields are required, there isn’t any relationship, simply both are Validation.required at their respective field levels.</p>\\n<p>This is how we can build a reusable Custom validates for each of these cases.</p>\\n<pre name=\\\"a34e\\\" id=\\\"a34e\\\" class=\\\"graf graf--pre graf-after--p\\\">class CustomValidators {  \\n\\n  static requiredWhen(requiredControlName, controlToCheckName) {  \\n    return (control: AbstractControl) => {  \\n      const required = control.get(requiredControlName);  \\n      const toCheck = control.get(controlToCheckName);  \\n      if (required.value || !toCheck.value) {  \\n        removeErrors(['required'], required);  \\n        return null;  \\n      }  \\n      const errorValue = `${requiredControlName}_Required_When_${controlToCheckName}`;  \\n      setErrors({required: errorValue}, required);  \\n      return {[errorValue]: true};  \\n    };  \\n  }</pre>\\n<pre name=\\\"20ef\\\" id=\\\"20ef\\\" class=\\\"graf graf--pre graf-after--pre\\\">static requiredEither(requiredControlName, controlToCheckName) {  \\n    return (control) => {  \\n      const required = control.get(requiredControlName);  \\n      const toCheck = control.get(controlToCheckName);  \\n      if (required.value || toCheck.value) {  \\n        removeErrors(['required'], required);  \\n        removeErrors(['required'], toCheck);  \\n        return null;  \\n      }  \\n      const errorValue = `${requiredControlName}_Required_Either_${controlToCheckName}`;  \\n      setErrors({required: errorValue}, required);  \\n      setErrors({required: errorValue}, toCheck);  \\n      return {[errorValue]: true};  \\n    };  \\n  }</pre>\\n<pre name=\\\"5e9f\\\" id=\\\"5e9f\\\" class=\\\"graf graf--pre graf-after--pre\\\">static requiredWhenNot(requiredControlName, controlToCheckName) {  \\n    return (control) => {  \\n      const required = control.get(requiredControlName);  \\n      const toCheck = control.get(controlToCheckName);  \\n      if (required.value || toCheck.value) {  \\n        removeErrors(['required'], required);  \\n        return null;  \\n      }  \\n      const errorValue = `${requiredControlName}_Required_When_Not_${controlToCheckName}`;  \\n      setErrors({required: errorValue}, required);  \\n      return  {[errorValue]: true};  \\n    };  \\n  }</pre>\\n<pre name=\\\"6a83\\\" id=\\\"6a83\\\" class=\\\"graf graf--pre graf-after--pre\\\">}</pre>\\n<pre name=\\\"8f05\\\" id=\\\"8f05\\\" class=\\\"graf graf--pre graf-after--pre\\\">function setErrors(error: {[key: string]: any }, control: AbstractControl) {  \\n  control.setErrors({...control.errors, ...error});  \\n}</pre>\\n<pre name=\\\"54a1\\\" id=\\\"54a1\\\" class=\\\"graf graf--pre graf-after--pre\\\">function  removeErrors(keys: string[], control: AbstractControl) {  \\n  const remainingErrors = keys.reduce((errors, key) => {  \\n    delete  errors[key];  \\n    return errors;  \\n  }, {...control.errors});  \\n  control.setErrors(Object.keys(remainingErrors).length > 0 ? remainingErrors : null);  \\n}</pre>\\n<p>Use them declarively in your your FromBuilder group definations.</p>\\n<pre name=\\\"abff\\\" id=\\\"abff\\\" class=\\\"graf graf--pre graf-after--p\\\">class AppComponent implements OnInit  {</pre>\\n<pre name=\\\"040f\\\" id=\\\"040f\\\" class=\\\"graf graf--pre graf-after--pre\\\">registerForm: FormGroup;  \\n    submitted = false;  \\n\\n  constructor( [@Inject](http://twitter.com/Inject \\\"Twitter profile for @Inject\\\")(FormBuilder) private formBuilder: FormBuilder) {}</pre>\\n<pre name=\\\"dbfe\\\" id=\\\"dbfe\\\" class=\\\"graf graf--pre graf-after--pre\\\">ngOnInit() {  \\n        this.registerForm = this.formBuilder.group({  \\n            firstName: ['', Validators.required],  \\n            phone: ['', [Validators.pattern('[0-9]*')]],  \\n            email: ['', [ Validators.email]]  \\n        },  \\n        {  \\n          validator: [  \\n            CustomValidators.requiredEither('email', 'phone')  \\n          ]  \\n        }                                             \\n       );  \\n    }  \\n\\n    // convenience getter for easy access to form fields  \\n    get f() { return this.registerForm.controls; }  \\n\\n    onSubmit() {  \\n        this.submitted = true;  \\n\\n        // stop here if form is invalid  \\n        if (this.registerForm.invalid) {  \\n            return;  \\n        }  \\n        alert(`Submitted -> ${JSON.stringify(this.registerForm.value)}`);  \\n    }</pre>\\n<pre name=\\\"2459\\\" id=\\\"2459\\\" class=\\\"graf graf--pre graf-after--pre\\\">}</pre>\\n<p>Template just reacts to validation control</p>\\n<pre name=\\\"4ad8\\\" id=\\\"4ad8\\\" class=\\\"graf graf--pre graf-after--p\\\"><form [formGroup]=\\\"registerForm\\\" (ngSubmit)=\\\"onSubmit()\\\">  \\n <label>   \\n    Phone <input formControlName=\\\"phone\\\">  \\n </label>  \\n <div *ngIf=\\\"f.phone.errors\\\" class=\\\"invalid-feedback\\\">  \\n    <div *ngIf=\\\"f.phone.errors.required\\\">  \\n     Phone number is required if email is not given.</div>  \\n     <div *ngIf=\\\"f.phone.errors.pattern\\\">  \\n     Phone number must match pattern digits</div>  \\n </div></pre>\\n<pre name=\\\"4f4c\\\" id=\\\"4f4c\\\" class=\\\"graf graf--pre graf-after--pre\\\"><label>   \\n   Email <input formControlName=\\\"email\\\">  \\n </label>  \\n <div *ngIf=\\\"f.email.errors\\\">  \\n    <div *ngIf=\\\"f.email.errors.required\\\">  \\n    Email is required ({{f.email.errors.required}}).  \\n    </div>  \\n    <div *ngIf=\\\"f.email.errors.email\\\">  \\n    Email must be a valid email address  \\n    </div>                          \\n</div></pre>\\n<pre name=\\\"6adf\\\" id=\\\"6adf\\\" class=\\\"graf graf--pre graf-after--pre\\\"><button [disabled]=\\\"registerForm.invalid\\\" type=\\\"submit\\\">  \\n Register  \\n</button></pre>\\n<pre name=\\\"73df\\\" id=\\\"73df\\\" class=\\\"graf graf--pre graf-after--pre\\\"></form></pre>\\n<p>Checkout full working code at <a href=\\\"https://codepen.io/simars/pen/ZMYxrm\\\">https://codepen.io/simars/pen/ZMYxrm</a></p>\",\"frontmatter\":{\"path\":\"/custom-transitive-validators-in-reactive-forms-angular\",\"title\":\"Build {Cross-field / Transitive Validators} for {Reactive Forms} | Angular\",\"author\":\"Simar Paul Singh\",\"date\":\"2018-05-07\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/custom-transitive-validators-in-reactive-forms-angular.json\n// module id = 334\n// module chunks = 45993978181358"],"sourceRoot":""}