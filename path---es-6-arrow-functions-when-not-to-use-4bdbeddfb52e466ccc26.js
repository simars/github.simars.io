webpackJsonp([7256621977282],{347:function(e,n){e.exports={data:{markdownRemark:{html:"<p>Arrow functions or Lambdas, were introduced in ES 6. Apart from its elegance in minimal syntax, most notable functional <strong>difference is scoping of</strong> <code>this</code> <strong>inside an arrow function</strong></p>\n<blockquote>\n<p>In <strong>regular function</strong> expressions, the <code>this</code> keyword is bound to different values based on the <em>context</em> in which it is called.</p>\n</blockquote>\n<blockquote>\n<p>In <strong>arrow functions</strong>, <code>this</code> is <em>lexically</em> bound, which means it closes over <code>this</code> from the scope in which the arrow function was defined (parent-scope), and does not change no matter where and how it is invoked / called.</p>\n</blockquote>\n<h3>Limitations Arrow-Functions as methods on an Object</h3>\n<pre><code>// this = global Window\nlet objA = {\n id: 10,\n name: \"Simar\",\n print () { // same as print: function() \n  console.log(`[${this.id} -> ${this.name}]`);\n }\n}\nobjA.print(); // logs: [10 -> Simar]\nobjA = {\n id: 10,\n name: \"Simar\",\n print: () => {\n  // closes over this lexically (global Window)\n  console.log(`[${this.id} -> ${this.name}]`);\n }\n};\nobjA.print(); // logs: [undefined -> undefined]\n</code></pre>\n<p>In the case of <code>objA.print()</code> when <code>print()</code> method defined using regular <code>function</code> , it worked by resolving <code>this</code> properly to <code>objA</code> for method invocation but failed when defined as an arrow<code>=></code> function. It is because <code>this</code> in a regular function when invoked as a method on an object (<code>objA</code>), is the object itself. However, in case of an arrow function, <code>this</code> gets lexically bound to the the <code>this</code> of the enclosing scope where it was defined (global / Window in our case) and stays it stays same during its invocation as a method on <code>objA</code>.</p>\n<h3>Advantages of an arrow-functions over regular functions in method(s) of an object BUT only when <code>this</code> is expected to be fixed &#x26; bound at the time definition.</h3>\n<pre><code>/* this = global | Window (enclosing scope) */\n\nlet objB = {\n id: 20,\n name: \"Paul\",\n print () { // same as print: function() \n  setTimeout( function() {\n    // invoked async, not bound to objB\n    console.log(`[${this.id} -> ${this.name}]`);\n  }, 1)\n }\n};\nobjB.print(); // logs: [undefined -> undefined]'\nobjB = {\n id: 20,\n name: \"Paul\",\n print () { // same as print: function() \n  setTimeout( () => {\n    // closes over bind to this from objB.print()\n    console.log(`[${this.id} -> ${this.name}]`);\n  }, 1)\n }\n};\nobjB.print(); // logs: [20 -> Paul]\n</code></pre>\n<p>In the case of <code>objB.print()</code> where <code>print()</code> method is defined as function that invokes <code>console.log(</code>[${this.id} -> {this.name}]<code>)</code> asynchronously as a call-back on <code>setTimeout</code> , <code>this</code> resolved correctly to <code>objB</code> when an arrow function was used as call-back but failed when call-back was defined as as regular function. It is because arrow <code>=></code> function passed to <code>setTimeout(()=>..)</code> closed over <code>this</code> lexically from its parent ie. invocation of <code>objB.print()</code> which defined it. In other-words, the arrow <code>=></code> function passed in to to <code>setTimeout(()==>...</code> bound to <code>objB</code> as its <code>this</code> because the in invocation of <code>objB.print()</code> <code>this</code> was <code>objB</code> itself.</p>\n<p>We could easily use <code>Function.prototype.bind()</code>, to make the call-back defined as a regular function work, by binding it to the correct <code>this</code>.</p>\n<pre><code>const objB = {\n id: 20,\n name: \"Singh\",\n print () { // same as print: function() \n  setTimeout( (function() {\n    console.log(`[${this.id} -> ${this.name}]`);\n  }).bind(this), 1)\n }\n}\nobjB.print() // logs: [20 -> Singh]\n</code></pre>\n<p>However, arrow functions come in handy and less error prone for the case of async call-backs where we know the <code>this</code> at the time of the functions definition to which it gets and should be bound.</p>\n<h3>Limitation of Arrow-Functions where this needs to change across invocations</h3>\n<p>Anytime, we need function whose <code>this</code> can be changed at time of invocation, we can’t use arrow functions.</p>\n<pre><code>/* this = global | Window (enclosing scope) */\n\nfunction print() { \n   console.log(`[${this.id} -> {this.name}]`);\n}\nconst obj1 = {\n id: 10,\n name: \"Simar\",\n print // same as print: print\n};\nobj.print(); // logs: [10 -> Simar]\nconst obj2 = {\n id: 20,\n name: \"Paul\",\n};\nprintObj2 = obj2.bind(obj2);\nprintObj2(); // logs: [20 -> Paul]\nprint.call(obj2); // logs: [20 -> Paul]\n</code></pre>\n<p>None of the above will work with arrow function <code>const print = () => { console.log(</code>[${this.id} -> {this.name}]<code>);}</code> as <code>this</code> can’t be changed and will stay bound to the <code>this</code> of the enclosing scope where it was defined (global / Window). In all these examples, we invoked the same function with different objects (<code>obj1</code> and <code>obj2</code>) one after the another, both of which were created after the <code>print()</code> function was declared.</p>\n<p>These were contrived examples, but let’s think about some more real life examples. If we had to write our <code>reduce()</code> method similar to one that works on <code>arrays</code> , we again can’t define it as a lambda, because it needs to infer <code>this</code> from the invocation context, ie. the array on which it was invoked</p>\n<p>For this reason, <code>constructor</code> functions can never be defined as arrow functions, as <code>this</code> for a constructor function can not be set at the time of its declaration. Every-time a constructor function is invoked with <code>new</code> keyword, a new object is created which then gets bound to that particular invocation.</p>\n<p>Also when when frameworks or systems accept a callback function(s) to be invoked later with dynamic context <code>this</code> , we can’t use arrow functions as again <code>this</code> may need to change with every invocation. This situation commonly arrises with DOM event handlers</p>\n<pre><code>'use strict'\nvar button = document.getElementById('button');\nbutton.addEventListener('click', function {\n  // web-api invokes with this bound to current-target in DOM\n  this.classList.toggle('on');\n});\nvar button = document.getElementById('button');\nbutton.addEventListener('click', () => {\n  // TypeError; 'use strict' -> no global this\n  this.classList.toggle('on');\n});\n</code></pre>\n<p>This is also the reason why in frameworks like <strong>Angular 2+</strong> and <strong>Vue.js</strong> expectthe template-component binding methods to be regular function / methods as <code>this</code> for their invocation is managed by the frameworks for the binding functions. (Angular uses Zone.js to manage async context for invocations of view-template binding functions)</p>\n<p>On the other hand, in <strong>React</strong>, when we want pass a component's method as an event-handler for example <code>&#x3C;input onChange={this.handleOnchange} /></code> we should define <code>handleOnchanage = (event)=> {this.props.onInputChange(event.target.value);}</code> as an arrow function as for every invocation, we want this to be same instance of the component that produced the JSX for rendered DOM element.</p>\n<hr>\n<p>This article is also aviable on my <a href=\"https://medium.com/simars/when-not-to-use-es6-arrow-functions-lambdas-41537a042839?source=friends_link&#x26;sk=8fc731e7afa441ee16ec694a499750b9\"><strong>Medium</strong></a> publication. If you like the artile, or have any comments and suggestions, please <strong><em>clap</em></strong> or leave <strong><em>comments</em></strong> on <a href=\"https://medium.com/simars/when-not-to-use-es6-arrow-functions-lambdas-41537a042839?source=friends_link&#x26;sk=8fc731e7afa441ee16ec694a499750b9\"><strong>Medium</strong></a>.</p>",frontmatter:{path:"/es6-arrow-functions-when-not-to-use",title:"ES6+ Arrow Functions [Lambdas] | When NOT to use",author:"Simar Paul Singh",date:"2019-03-05"}}},pathContext:{}}}});
//# sourceMappingURL=path---es-6-arrow-functions-when-not-to-use-4bdbeddfb52e466ccc26.js.map